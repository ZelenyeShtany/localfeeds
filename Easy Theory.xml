<feed xmlns:yt="http://www.youtube.com/xml/schemas/2015" xmlns:media="http://search.yahoo.com/mrss/" xmlns="http://www.w3.org/2005/Atom">
<link rel="self" href="http://www.youtube.com/feeds/videos.xml?channel_id=UC3VY6RTXegnoSD_q446oBdg"/>
<id>yt:channel:UC3VY6RTXegnoSD_q446oBdg</id>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2000-01-01T20:00:17+00:00</published><entry>
<id>yt:video:anwyKFYbLdQ</id>
<yt:videoId>anwyKFYbLdQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Merry Christmas and Happy Holidays from Easy Theory!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=anwyKFYbLdQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Merry Christmas and Happy Holidays from Easy Theory!</media:title>
<media:content url="https://www.youtube.com/v/anwyKFYbLdQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/anwyKFYbLdQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:L_Y6gAaLQmk</id>
<yt:videoId>L_Y6gAaLQmk</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #96: What is a Parse Tree (for context-free grammars + leftmost derivations)?</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=L_Y6gAaLQmk"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #96: What is a Parse Tree (for context-free grammars + leftmost derivations)?</media:title>
<media:content url="https://www.youtube.com/v/L_Y6gAaLQmk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/L_Y6gAaLQmk/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give a definition of what a parse tree is, and how it is relevant to context-free grammars. They are a visualization of how a derivation in a CFG is done. They correspond 1-to-1 with leftmost derivations. 

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:j_80-VjOnK8</id>
<yt:videoId>j_80-VjOnK8</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>ALL Closure Properties (Regular, CFL, etc.) and Decidability/Undecidability - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=j_80-VjOnK8"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>ALL Closure Properties (Regular, CFL, etc.) and Decidability/Undecidability - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/j_80-VjOnK8?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/j_80-VjOnK8/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show all closure properties of all language classes in the theory of computation class (regular, CFL, decidable, recognizable) as well as all decidability and undecidability results (A_X, E_X, EQ_X when X is DFA/NFA/regex, CFG/PDA, LBA, and TM). I also give brief reasons for each one of them why they are true.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:qFZAblZiO08</id>
<yt:videoId>qFZAblZiO08</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #126: E_CFG is decidable (what is a productive variable?) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=qFZAblZiO08"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #126: E_CFG is decidable (what is a productive variable?) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/qFZAblZiO08?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/qFZAblZiO08/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that the emptiness problem for context-free grammars (CFGs) is decidable. A variable is "productive" if it can make any string of terminals at all. So we formally define what a productive variable is, and repeatedly mark variables as productive by scanning through the rules. If no new variables are found, we stop and answer whether or not the start variable has been marked.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:e-KF6u6-Zqw</id>
<yt:videoId>e-KF6u6-Zqw</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #125: A_CFG is Decidable (what does 2|w|-1 have to do with it?) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=e-KF6u6-Zqw"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #125: A_CFG is Decidable (what does 2|w|-1 have to do with it?) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/e-KF6u6-Zqw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/e-KF6u6-Zqw/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that A_CFG is decidable. The main method of proof is the fact that any CFG in Chomsky Normal Form (CNF) will have all derivations of a string w of length 2|w|-1, if w is non-empty. The basic idea then is to try all possible derivations of that length. If any of them work, accept; otherwise, reject.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:ql0rBl29_fQ</id>
<yt:videoId>ql0rBl29_fQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #120: EQ_DFA is Decidable (equivalence for DFAs, three different proofs!)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=ql0rBl29_fQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #120: EQ_DFA is Decidable (equivalence for DFAs, three different proofs!)</media:title>
<media:content url="https://www.youtube.com/v/ql0rBl29_fQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/ql0rBl29_fQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give different proofs that EQ_DFA is decidable: (1) a different formulation of "equality" for two sets (namely regular languages), (2) minimization of DFAs, and (3) using the pumping lemma.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:fuJyQ7BBUPM</id>
<yt:videoId>fuJyQ7BBUPM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #119: E_DFA is decidable (Emptiness problem for DFAs) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=fuJyQ7BBUPM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #119: E_DFA is decidable (Emptiness problem for DFAs) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/fuJyQ7BBUPM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/fuJyQ7BBUPM/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that the E_DFA problem is decidable, which is determining for a given DFA, whether or not its language is empty. This is the same as determining if some final state is reachable from the DFA's start state. So we run breadth-first-search on the DFA (treating it as a graph), and report the opposite answer (see the video for why this is the case).

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:sPzvKqp0MBc</id>
<yt:videoId>sPzvKqp0MBc</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #118: A_REX is decidable (regular expression acceptance) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=sPzvKqp0MBc"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #118: A_REX is decidable (regular expression acceptance) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/sPzvKqp0MBc?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/sPzvKqp0MBc/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that A_REX is decidable, which is the problem of determining if a given regular expression can generate a given string. We show that this is decidable by converting the regex into an equivalent NFA, and calling the decider for A_NFA on that NFA and the same input string. Since the NFA and regex are equivalent, the answer reported is the same. Since all steps take finite time, this shows A_REX is decidable.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:_aEoMFJ0fuk</id>
<yt:videoId>_aEoMFJ0fuk</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Undecidability in 2 Hours (A_TM, Rice's Theorem, LBAs, EQ_CFG) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=_aEoMFJ0fuk"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Undecidability in 2 Hours (A_TM, Rice's Theorem, LBAs, EQ_CFG) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/_aEoMFJ0fuk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/_aEoMFJ0fuk/hqdefault.jpg" width="480" height="360"/>
<media:description>(I know there's a video/audio sync issue, I can't find a way to fix it, sorry! This is the recorded version of the livestream, so shouldn't have any dropped frames.) 

Here we cover everything to do with undecidability, such as the A_TM and E_TM problems. Also we do Rice's theorem, and show that certain problems for linear bounded automata (LBAs) and context-free grammars are undecidable.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:0KPwNmIdqXk</id>
<yt:videoId>0KPwNmIdqXk</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #117: A_NFA is Decidable (to convert or to not convert? That's the question!)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=0KPwNmIdqXk"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #117: A_NFA is Decidable (to convert or to not convert? That's the question!)</media:title>
<media:content url="https://www.youtube.com/v/0KPwNmIdqXk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/0KPwNmIdqXk/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that the A_NFA language is decidable. Note that this language has all pairs M, w where M is an NFA and w is a string such that M accepts w. We cannot just simulate M on w since there are choices. We then convert M into an equivalent DFA, and ask the decider for A_DFA the same question. 

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:PrF3Ci0FOPI</id>
<yt:videoId>PrF3Ci0FOPI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Easy Theory does not endorse Academic Integrity Violations (don't be stupid!)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=PrF3Ci0FOPI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Easy Theory does not endorse Academic Integrity Violations (don't be stupid!)</media:title>
<media:content url="https://www.youtube.com/v/PrF3Ci0FOPI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/PrF3Ci0FOPI/hqdefault.jpg" width="480" height="360"/>
<media:description>Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:q-Qau0RqmqE</id>
<yt:videoId>q-Qau0RqmqE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #116: A_DFA is Decidable (also, what is a "high-level" description?)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=q-Qau0RqmqE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #116: A_DFA is Decidable (also, what is a "high-level" description?)</media:title>
<media:content url="https://www.youtube.com/v/q-Qau0RqmqE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/q-Qau0RqmqE/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that the A_DFA problem is decidable, and introduce "high-level descriptions" of problems. The idea is to simulate the DFA by keeping track of the current input character as well as the current state, then repeatedly look in the transition function for what state to go next. Then, update that current state; at the end, we look to see if this state is a final state, and accept if and only if it is. The language is then decidable because this Turing Machine runs in a finite amount of time.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Lh7SckCEWVg</id>
<yt:videoId>Lh7SckCEWVg</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #115: What is an encoding? (and why should we care?) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Lh7SckCEWVg"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #115: What is an encoding? (and why should we care?) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Lh7SckCEWVg?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Lh7SckCEWVg/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we talk about encodings of machines, etc. The purpose of them is to have a string representation of machines so that we can talk about the language of machines that have a certain property. We use this to show that certain problems are decidable (and some to be not decidable), because the formulation of the language itself allows us to formally prove that it is decidable/not decidable.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:riiiPCLhRjc</id>
<yt:videoId>riiiPCLhRjc</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #114: What is the Church-Turing Thesis? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=riiiPCLhRjc"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #114: What is the Church-Turing Thesis? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/riiiPCLhRjc?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/riiiPCLhRjc/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that the "Church-Turing thesis" is true, which essentially says that our "intuitive" notion of an algorithm is equivalent to a Turing Machine. We show this by showing that all parts of "modern" algorithms can be done by a Turing machine, namely addition, subtraction, multiplication, division, and exponentiation. All "modern" algorithms are a finite combination of any of these operators working with binary numbers.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:lHN55ECoj-k</id>
<yt:videoId>lHN55ECoj-k</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #113: Turing Machine Variant 4: Nondeterministic Turing Machines (NTMs)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=lHN55ECoj-k"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #113: Turing Machine Variant 4: Nondeterministic Turing Machines (NTMs)</media:title>
<media:content url="https://www.youtube.com/v/lHN55ECoj-k?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/lHN55ECoj-k/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the final variant of Turing Machines: the nondeterministic TM (NTM), which allows any number of transitions from any state and tape symbol observed. We show how to have a deterministic TM simulate such a machine with the "computation tree" approach (although it isn't actually a tree!). The idea is to do a "breadth first search" of the tree, one level at a time, and if a q_accept is reached, then we accept. If not, we have to do several things to make sure this machine is a decider iff the original nondeterministic machine was, but it can be done. 

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:g8b-cPEZGy4</id>
<yt:videoId>g8b-cPEZGy4</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #112: Turing Machine Variant 3: Multi-Tape Turing Machines - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=g8b-cPEZGy4"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #112: Turing Machine Variant 3: Multi-Tape Turing Machines - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/g8b-cPEZGy4?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/g8b-cPEZGy4/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we examine the Turing Machine variant where we are allowed to have any fixed number of tapes k at least 1. This seems more powerful than the standard model, as each of the tapes can move in any direction, and is fully independent (in a certain sense) of the other tapes. We show that this model is in fact equivalent to the standard model by putting all k tapes onto one with delimiters separating them. We then look at the details of how to carry out the simulation, and realize that there is a LOT of work to be done (number of states, new tape characters, etc.). But all of the work is finite, and can be done algorithmically.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:q8mOnYGQWK8</id>
<yt:videoId>q8mOnYGQWK8</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #111: Turing Machine Variant 2: Left-Reset Turing Machine (LRTM) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=q8mOnYGQWK8"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #111: Turing Machine Variant 2: Left-Reset Turing Machine (LRTM) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/q8mOnYGQWK8?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/q8mOnYGQWK8/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at another Turing machine variant, namely the left-reset Turing Machine (LRTM). Here, the RESET instruction will have the tape head immediately jump to the first cell on the tape. The way to simulate this is with (1) shifting the input 1 cell to the right, (2) placing a special symbol in the first cell of the tape, and (3) whenever we want to simulate a RESET transition, execute multiple L transitions until we encounter the $, and then move R one position. We go over the many details needed in how to implement this correctly, but this is the basic idea.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:GRXwS-NRezc</id>
<yt:videoId>GRXwS-NRezc</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #110: Turing Machine Variant 1: Stay-Put Turing Machine (STM) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=GRXwS-NRezc"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #110: Turing Machine Variant 1: Stay-Put Turing Machine (STM) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/GRXwS-NRezc?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/GRXwS-NRezc/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we start the first of Turing Machine variants, namely the stay-put Turing machine (STM). Variants indicate changes to the machine model that don't change the computational power of the underlying model. So here, we show that STMs are equivalent to the "standard" TM model.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:SrV5j48oUgE</id>
<yt:videoId>SrV5j48oUgE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #109: Turing Machine Definitions (Configuration, Computation, Yields, Halting)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=SrV5j48oUgE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #109: Turing Machine Definitions (Configuration, Computation, Yields, Halting)</media:title>
<media:content url="https://www.youtube.com/v/SrV5j48oUgE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/SrV5j48oUgE/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we define many terms for Turing Machines (TMs), namely configuration, computation, halting, accepting, rejecting, and yields. All of them are based on the behavior of TMs, and how to precisely define what computing on a TM actually means. 

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:aQTdCUpNI6g</id>
<yt:videoId>aQTdCUpNI6g</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #108: Turing Machine Example and Computation (Can you guess what it does?)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=aQTdCUpNI6g"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #108: Turing Machine Example and Computation (Can you guess what it does?)</media:title>
<media:content url="https://www.youtube.com/v/aQTdCUpNI6g?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/aQTdCUpNI6g/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give an example of a Turing Machine (TM), and go through computing a given input string on that TM. We have to keep track of (1) the contents of the tape, (2) where the tape head is on the tape, and (3) what state we are currently in. There are a lot of steps, but each one is quite simple. We also go over conventions in how the transitions are written (as well as what happens if they are not written). Can you guess what the TM actually computes?

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:j0bIxPqlYLE</id>
<yt:videoId>j0bIxPqlYLE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #107: Turing Machines - what are they? (+ Formal Definition) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=j0bIxPqlYLE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #107: Turing Machines - what are they? (+ Formal Definition) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/j0bIxPqlYLE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/j0bIxPqlYLE/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we define what a Turing machine (TM) is, and give a formal definition. It's an extension of a DFA or a PDA in that (1) the input can be overwritten with new values, (2) the "tape head" can move back and forth, and (3) new cells can be allocated at any point (if the tape head is at the "right end" and tries to move right). We will eventually show that this is equivalent to the modern notion of a "computer."

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:jB-aRCR41xc</id>
<yt:videoId>jB-aRCR41xc</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Turing Machines + Decidability in 3 Hours (TM, Variants, Church-Turing, Decidability) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=jB-aRCR41xc"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Turing Machines + Decidability in 3 Hours (TM, Variants, Church-Turing, Decidability) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/jB-aRCR41xc?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/jB-aRCR41xc/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do a livestream covering everything to do with Turing Machines and Decidability. We cover Turing Machines (and their formal definition), what a "high-level" problem description is, several variants of Turing Machines (nondeterministic, multitape, etc.), the importance and truth of the Church-Turing thesis, encodings of machines, and decidability problems involving DFAs and CFGs.

Timestamps:
0:00 - Intro
7:43 - Start of topics
8:18 - Review/Motivation for a new model
12:13 - Definition of a TM
27:26 - Example of a TM 
37:47 - What is a configuration, a computation and few more terms.
45:18 - Decidable language
47:18 - TM Variants
1:06:10 - More TM Variants (Multi-tape TM, Nondeterministic TM)
1:26:20 - Computation tree
1:34:25 - Can TMs do arithmetic?
1:41:15 - Church-Turing Thesis
1:44:09 - Problems for TMs ("High-level" algorithm/Encodings) 
1:58:49 - Acceptance problems involving DFA, NFA, Regex, etc.
2:13:42 - "Emptiness" Problem for DFAs (E_DFA)
2:19:15 - "Equivalence" Problem for DFAs (EQ_DFA)
2:28:46 - "Acceptance" Problem (for CFGs)
2:39:14 - "Emptiness" Problem for CFGs
2:48:50 - End

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:qGOw0n9gJR4</id>
<yt:videoId>qGOw0n9gJR4</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #106: Deterministic Context-Free Languages NOT Closed Under Concatenation</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=qGOw0n9gJR4"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #106: Deterministic Context-Free Languages NOT Closed Under Concatenation</media:title>
<media:content url="https://www.youtube.com/v/qGOw0n9gJR4?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/qGOw0n9gJR4/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that deterministic context-free languages (DCFLs) are not closed under concatenation. The idea is to have two languages whose concatenation is the complement of {a^n b^n c^n : n at least 0}, which is not a DCFL. 

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:p13gJTzWPO8</id>
<yt:videoId>p13gJTzWPO8</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #105: Deterministic CFLs NOT Closed Under Union or Intersection</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=p13gJTzWPO8"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #105: Deterministic CFLs NOT Closed Under Union or Intersection</media:title>
<media:content url="https://www.youtube.com/v/p13gJTzWPO8?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/p13gJTzWPO8/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give a proof that deterministic context-free languages (DCFLs) are NOT closed under union. We use the prototypical not-DCFL, the complement of {a^n b^n c^n : n at least 0}, and show that it is the union of regular languages and three DCFLs. Since DCFLs are closed under union with regular languages, then union-ing the three DCFLs must result in a language that isn't a DCFL. We also get that they're not closed under intersection for free.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:f5d1hJQZTAs</id>
<yt:videoId>f5d1hJQZTAs</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #104: Deterministic Context-Free Languages Closed under Complement (DCFLs)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=f5d1hJQZTAs"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #104: Deterministic Context-Free Languages Closed under Complement (DCFLs)</media:title>
<media:content url="https://www.youtube.com/v/f5d1hJQZTAs?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/f5d1hJQZTAs/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that deterministic context-free languages (DCFLs) are closed under complement. They are "deterministic" so the "swap final and non-final states" idea for closure under complement for DFAs is a good idea. However, this doesn't directly work since there are epsilon transitions, and it's possible (because of the stack) that the DPDA becomes "stuck" in a state. So we fix these problems by (1) putting a $ at the beginning and going to two special states whenever we encounter the $ at a later point (these states either accept immediately or reject and read the rest of the string), (2) ensure the entire input is read, and then (3) breaking up transitions into "reading" ones and "non-reading" ones, and ensuring that once we enter a final state, we don't "leave" a final state until we encounter another reading transition.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:GzR5FiiIogY</id>
<yt:videoId>GzR5FiiIogY</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #103: Deterministic Context-Free Languages (DCFLs) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=GzR5FiiIogY"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #103: Deterministic Context-Free Languages (DCFLs) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/GzR5FiiIogY?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/GzR5FiiIogY/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we introduce deterministic context-free languages, and give an example (namely {0^n 1^n}). The point is to determine whether or not a "deterministic" CFL is equivalent to a "nondeterministic" CFL. All DCFLs are CFLs, but is the converse true?

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:-ML_B8_7TcE</id>
<yt:videoId>-ML_B8_7TcE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #102: Context-Free Elections (pumping lemma for CFLs proofs too) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=-ML_B8_7TcE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #102: Context-Free Elections (pumping lemma for CFLs proofs too) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/-ML_B8_7TcE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/-ML_B8_7TcE/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we phrase three languages that are related to elections: they are all strings in {a,b,c,d}* where each of the letters is a candidate. One of them wins by majority if he/she gets strictly more than 50% of the vote, and by plurality if he/she gets more votes than any other candidate. We show that the problem of checking if a candidate (say, c) wins by majority is context-free (by "relabelling"), and checking if c wins by majority *and* one candidate beats another candidate is NOT context-free. We then get an alternate proof that context-free languages are not closed under intersection.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:v4ZjggNXW3Q</id>
<yt:videoId>v4ZjggNXW3Q</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #99: Pumping Lemma for Context-Free Languages, 4 PROOFS and Examples</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=v4ZjggNXW3Q"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #99: Pumping Lemma for Context-Free Languages, 4 PROOFS and Examples</media:title>
<media:content url="https://www.youtube.com/v/v4ZjggNXW3Q?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/v4ZjggNXW3Q/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give four proofs of languages not being context-free:
1) {a^n b^n c^n : n at least 0}
2) {a^i b^j c^k : i at most j, j at most k}
3) {ww : w in {0,1}*}
4) {w in {a,b,c,d}* : w has more c's than a's, b's, or d's}
In each, we go through a proof to show that each language is not context-free by first assuming that it is context-free, then using the fact that there is a pumping constant p for each language, finding a string that cannot be pumped. 

Timestamps:
0:00 - Intro
1:00 - Main steps in proofs
3:30 - {a^n b^n c^n : n at least 0}
14:20 - {a^i b^j c^k : i at most j, j at most k}
24:00 - {ww : w in {0,1}*}
37:30 - {w in {a,b,c,d}* : w has more c's than a's, b's, or d's}

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:qOFWP_m9t7k</id>
<yt:videoId>qOFWP_m9t7k</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Context-Free Languages in 3.5 Hours (CFG, PDA, Conversions, Closure, Pumping Lemma) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=qOFWP_m9t7k"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Context-Free Languages in 3.5 Hours (CFG, PDA, Conversions, Closure, Pumping Lemma) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/qOFWP_m9t7k?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/qOFWP_m9t7k/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do a livestream covering everything to do with context-free languages. We cover context-free grammars (CFGs and two examples), pushdown automata (PDAs), the conversion from a CFG to a PDA, the conversion from a PDA to a CFG, the pumping lemma for context-free languages, and closure properties (as well as operations CFLs are not closed under). 

Timestamps:
0:00 - Start of livestream
21:19 - Start of topics
24:10 - Definition of CFG
31:20 - Example 1 of CFG (with definitions)
41:30 - Example 2 of CFG (balanced parentheses)
47:30 - CFLs closed under union, concat, star
59:40 - Chomsky Normal Form definition
1:09:11 - CFG to CNF start
1:13:38 - Step 1 of CNF conversion
1:15:22 - Step 2 of CNF conversion
1:20:05 - Step 3 of CNF conversion
1:23:53 - Step 4 of CNF conversion
1:28:12 - Step 5 of CNF conversion
1:39:50 - PDA definition
1:45:00 - PDA example
1:49:50 - CFG to PDA
2:01:10 - PDA to CFG
2:36:30 - Proof of Pumping Lemma for CFLs
2:55:40 - Pumping Lemma for CFLs statement
2:58:50 - Proving {0^n 1^n 2^n} is not a CFL
3:07:40 - CFLs not closed under complement or intersection
3:23:10 - Wrapup

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:mRkXE-ZHqCw</id>
<yt:videoId>mRkXE-ZHqCw</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #97: Parse Trees and CFGs in Chomsky Normal Form - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=mRkXE-ZHqCw"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #97: Parse Trees and CFGs in Chomsky Normal Form - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/mRkXE-ZHqCw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/mRkXE-ZHqCw/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the structure of parse trees for context-free grammars in Chomsky Normal Form. The idea is that since the right hand side of any rule has at most 2 variables or terminals, the corresponding parse tree is always binary for all internal nodes (i.e., has two children), except for the nodes at the bottom, which all have exactly 1 or 0 children. We will use this to prove that there are some languages that are not context-free.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:-UH9L2sJpPQ</id>
<yt:videoId>-UH9L2sJpPQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #98: Pumping Lemma for Context-Free Languages, Statement and Proof</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=-UH9L2sJpPQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #98: Pumping Lemma for Context-Free Languages, Statement and Proof</media:title>
<media:content url="https://www.youtube.com/v/-UH9L2sJpPQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/-UH9L2sJpPQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we prove (and state) the pumping lemma for context-free languages (CFL), by observing a parse tree of a CFG in Chomsky Normal Form (CNF). The properties of the parse tree allow us to show that if the string generated is big enough, the longest root-to-leaf path in the parse tree must repeat a variable. We utilize this fact to generate more parse trees (i.e., more strings the CFG makes), and look at the properties of parts of this string.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:bK8LVFWA0L8</id>
<yt:videoId>bK8LVFWA0L8</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Regular Languages in 4 Hours (DFA, NFA, Regex, Pumping Lemma, all conversions) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=bK8LVFWA0L8"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Regular Languages in 4 Hours (DFA, NFA, Regex, Pumping Lemma, all conversions) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/bK8LVFWA0L8?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/bK8LVFWA0L8/hqdefault.jpg" width="480" height="360"/>
<media:description>This is a livestream teaching everything you need to know about regular languages, from the start to the end. We covered DFAs, NFAs, regular expressions, and the pumping lemma (to help prove some languages are not regular). We also covered the product construction (union of two DFAs), powerset construction (NFA to DFA), regular expression to NFA (Thompson's construction), NFA to regular expression (GNFA method), and two proofs using the pumping lemma. 

Timestamps:
0:00 - Start of livestream
20:38 - Start of topics
21:45 - Existence of unsolvable problems
23:56 - What is a computer?
25:56 - Restricting to 1 input/output
30:25 - Restricting to 1 bit output
33:00 - What is a "state" of the computer?
34:45 - Assumptions
37:45 - Example 1
44:35 - Example 2
53:00 - DFA definition
1:02:00 - Formal DFA example
1:12:25 - DFA more definitions (computation, etc.)
1:18:30 - Examples of regular languages
1:22:08 - Closure operations
1:25:15 - Regular operations
1:31:23 - Complement operation
1:32:23 - Regular languages closed under complement
1:35:45 - Regular languages closed under union (Product construction)
1:47:30 - Regular languages closed under intersection
1:49:47 - What about concatenation?
1:53:12 - NFA Definition
1:57:15 - NFA closure for regular operations
2:11:00 - Relationship between NFAs and DFAs
2:13:00 - NFA to DFA (Powerset construction)
2:29:10 - Regular expression definition
2:31:24 - Example regexes
2:36:12 - Regex to NFA (Thompson construction)
2:39:45 - Regex to NFA example
2:45:30 - NFA to Regex (GNFA Method)
2:58:00 - NFA to Regex example
3:17:50 - What other strings are accepted?
3:28:50 - Pumping Lemma statement
3:35:00 - Proof that 0^n1^n is not regular
3:41:10 - Proof that perfect squares are not regular

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:md3LrsOrHuE</id>
<yt:videoId>md3LrsOrHuE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #94: How big is the CFG from the PDA to CFG conversion? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=md3LrsOrHuE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #94: How big is the CFG from the PDA to CFG conversion? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/md3LrsOrHuE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/md3LrsOrHuE/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we ask the question of how big the CFG is from the PDA to CFG conversion. The CFG to PDA conversion, in contrast, results in a PDA where the size can be easily determined from only knowing the number of variables and rules in the CFG. Here, we determine that we can only know the number of Type I and Type II rules exactly (as well as number of variables), and for Type III, we can find a lower and upper bound on the number of rules.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:GaQPxCgSAMQ</id>
<yt:videoId>GaQPxCgSAMQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #93: PDA to CFG Conversion Example (Pushdown Automata to Context-Free Grammar)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=GaQPxCgSAMQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #93: PDA to CFG Conversion Example (Pushdown Automata to Context-Free Grammar)</media:title>
<media:content url="https://www.youtube.com/v/GaQPxCgSAMQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/GaQPxCgSAMQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give an example of the PDA to CFG conversion process. It starts by modifying the PDA so that there is a single final state, the stack ends empty, and every transition either pushes or pops but not both. Then we add Type I, II, and III rules. The first two only depend on the states, and Type III relies on finding "matching" transitions (i.e., a pair where one pushes a symbol x, and the other pops the same symbol x).

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:utlPZgorDLg</id>
<yt:videoId>utlPZgorDLg</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Regular Languages Closed Under Inverse (Homo)Morphism - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=utlPZgorDLg"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Regular Languages Closed Under Inverse (Homo)Morphism - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/utlPZgorDLg?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/utlPZgorDLg/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that regular languages are closed under inverse (homo)morphism. The idea is to have a DFA for L, and imagine any string w in L. Then a DFA for h^-1(L) would have to determine if there is a string z such that h(z) = w. The trick is to realize that the homomorphism property is useful in that we can "break up" the string w corresponding to individual characters of z, and so define the transition function for the "inverse" DFA on input a to be wherever h(a) went from that state.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:X0nrYIVGs3M</id>
<yt:videoId>X0nrYIVGs3M</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #92: PDA to CFG Conversion (Pushdown Automaton to Context-Free Grammar)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=X0nrYIVGs3M"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #92: PDA to CFG Conversion (Pushdown Automaton to Context-Free Grammar)</media:title>
<media:content url="https://www.youtube.com/v/X0nrYIVGs3M?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/X0nrYIVGs3M/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we outline the PDA to CFG conversion, which involves utilizing the "recursive" structure of the PDA we modified in the last video. The variables of the grammar involve going from one state of the PDA to another with the same stack height. Then it is simply modeling what the "base" case is, and how the "inductive" cases will work, all as rules in the CFG.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Y2W-IBSMqhc</id>
<yt:videoId>Y2W-IBSMqhc</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #91: Analysis of Stack Heights in a PDA (PDA to CFG Part 1) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Y2W-IBSMqhc"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #91: Analysis of Stack Heights in a PDA (PDA to CFG Part 1) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Y2W-IBSMqhc?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Y2W-IBSMqhc/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we make a simple analysis of stack heights after simplifying the PDA (single final state and every transition either pushes or pops, but not both). We note that the stack height after every transition, the height always changes by 1 (either up or down). We then look at the individual "mountains" of the computation (where the stack reaches a "peak" and then comes back down to "level 0"), and see how to solve a "smaller" version of the same problem. This gives insight into how to convert the PDA into a context-free grammar (CFG).

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:dBdLhz14NSE</id>
<yt:videoId>dBdLhz14NSE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #90: Simple Simplifications to PDAs (Force the Stack Empty!) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=dBdLhz14NSE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #90: Simple Simplifications to PDAs (Force the Stack Empty!) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/dBdLhz14NSE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/dBdLhz14NSE/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we make two adjustments to PDAs that we can always assume: that the stack is forced to be empty, and that every transition either pushes or pops, but not both. This is the start of the conversion from CFG to PDA, and allows the stack to change height by 1 on every transition. (Note that the "final" step at the end of the video is not complete because it has triple-epsilon transitions in it; see if you can "fix" it ;)

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:_Hp7giDiS74</id>
<yt:videoId>_Hp7giDiS74</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>(Homo)Morphisms vs. Substitutions + Regular Language Closure Properties - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=_Hp7giDiS74"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>(Homo)Morphisms vs. Substitutions + Regular Language Closure Properties - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/_Hp7giDiS74?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/_Hp7giDiS74/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we introduce morphisms (also called homomorphisms) and substitutions, and briefly show that regular languages are closed under both operations. The general principle is that morphisms map strings to strings, and substitutions map strings to languages; otherwise, they behave very similarly. We can assume that each maps a single character (or epsilon) to a string (for morphisms) or language (for substitutions).

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy, Ben Pritchard

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:-LN5-GvV-bQ</id>
<yt:videoId>-LN5-GvV-bQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Maximum Independent Set in Trees (Linear Time Algorithm) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=-LN5-GvV-bQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Maximum Independent Set in Trees (Linear Time Algorithm) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/-LN5-GvV-bQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/-LN5-GvV-bQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give a linear time algorithm for the maximum independent set problem for trees. A tree is a graph without cycles, and an independent set is a set of vertices without edges between them. The trick here is that trees don't have cycles, so answering a question about a vertex and its neighbors partitions the rest of the vertices into "clusters" that have no vertices in common. So we can solve the problem independently for each of the neighbors.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy, Ben Pritchard

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:iwcqjM-shQI</id>
<yt:videoId>iwcqjM-shQI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>What is a graph? Endless Definitions! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=iwcqjM-shQI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>What is a graph? Endless Definitions! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/iwcqjM-shQI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/iwcqjM-shQI/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give many definitions involving graphs, which is a model for relationships between various "entities." We define most of the "simple" definitions, such as directed graphs, subgraphs, multigraphs, trees, etc.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy, Ben Pritchard

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:-mXxr-mLD4c</id>
<yt:videoId>-mXxr-mLD4c</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>100k Views!!! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=-mXxr-mLD4c"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>100k Views!!! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/-mXxr-mLD4c?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/-mXxr-mLD4c/hqdefault.jpg" width="480" height="360"/>
<media:description>Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:SSJ0i-I2VXU</id>
<yt:videoId>SSJ0i-I2VXU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #88: Pushdown Automaton (PDA) for {0^n 1^n : n at least 0} - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=SSJ0i-I2VXU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #88: Pushdown Automaton (PDA) for {0^n 1^n : n at least 0} - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/SSJ0i-I2VXU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/SSJ0i-I2VXU/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we derive a PDA for the infamous non-regular language {0^n 1^n : n at least 0}. We give some tips as well for how to solve other PDAs. The general aspect here is to "match" 0s with 1s by pushing 0s onto the stack, and popping the 1s in tandem. There is some complication with popping an empty stack, so we push a "dummy" character on the stack to detect when the matching has concluded to avoid this problem.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Br44Zxv84-Q</id>
<yt:videoId>Br44Zxv84-Q</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #87: What even IS a PDA (Pushdown Automaton)? + Motivation - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Br44Zxv84-Q"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #87: What even IS a PDA (Pushdown Automaton)? + Motivation - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Br44Zxv84-Q?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Br44Zxv84-Q/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give a high-level overview of a pushdown automaton (PDA), and give the motivation for why we want such a model. It is (going to be) a machine model for the context-free languages, and is essentially an NFA with a stack.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:xBtj0-miWNM</id>
<yt:videoId>xBtj0-miWNM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Removing Trailing Zeroes is Regular! (Quotient Language Example) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=xBtj0-miWNM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Removing Trailing Zeroes is Regular! (Quotient Language Example) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/xBtj0-miWNM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/xBtj0-miWNM/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do an example of removing trailing zeroes from all strings in a regular language L, and showing that the resulting language is also regular. The trick is to use the fact that regular languages are closed under quotient, and to "massage" the language to get the strings into the correct format. Then it's just a matter of using known (easier) closure properties.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:PgUB_07N0eA</id>
<yt:videoId>PgUB_07N0eA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Quotient Languages (Cool Regular Language Closure Property!) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=PgUB_07N0eA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Quotient Languages (Cool Regular Language Closure Property!) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/PgUB_07N0eA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/PgUB_07N0eA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at "quotient languages" and show an advanced topic in theory of computation - that we can show a DFA exists without knowing how to produce it. Moreover, we show that regular languages are closed under quotient, but also closed under quotient with any language at all! 

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:kF0vtzMQC1o</id>
<yt:videoId>kF0vtzMQC1o</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #11: GATE 2017 Set 2 Question 30 (Master Theorem) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=kF0vtzMQC1o"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #11: GATE 2017 Set 2 Question 30 (Master Theorem) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/kF0vtzMQC1o?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/kF0vtzMQC1o/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we solve GATE 2017 Set 2 question 30, which is solving a recurrence relation. The master theorem cannot be applied to this problem directly, but we use two "domain transformations" to convert the problem into one that can be solved using the master theorem. Then we solve the original problem after substituting the original input size back in.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:ZGmUTe1uiE0</id>
<yt:videoId>ZGmUTe1uiE0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #10: The "Master" Theorem/Method, Derivation - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=ZGmUTe1uiE0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #10: The "Master" Theorem/Method, Derivation - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/ZGmUTe1uiE0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/ZGmUTe1uiE0/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give a proof of the "master" theorem, which is a derivation of the runtime for all recursive algorithms obeying a recurrence of the form T(n) = aT(n/b) + f(n) (i.e., a subproblems of size n/b, and f(n) time to combine the solutions). We see that there are 3 different cases, mainly based on how big f(n) is compared to a, b, and n. We look at a "computation tree" to show what the runtime across all nodes will be.

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Xs_kkCowLn8</id>
<yt:videoId>Xs_kkCowLn8</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Creating the Easy Theory Website #2 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Xs_kkCowLn8"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Creating the Easy Theory Website #2 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Xs_kkCowLn8?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Xs_kkCowLn8/hqdefault.jpg" width="480" height="360"/>
<media:description>Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:qVnXMXt6Ww0</id>
<yt:videoId>qVnXMXt6Ww0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #84: GATE 2020 Question 42 (p Factorial Trick, Hard Pumping Lemma!)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=qVnXMXt6Ww0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #84: GATE 2020 Question 42 (p Factorial Trick, Hard Pumping Lemma!)</media:title>
<media:content url="https://www.youtube.com/v/qVnXMXt6Ww0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/qVnXMXt6Ww0/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at GATE 2020 Question 42, which involves classifying whether two languages are regular, context-free but not regular, or neither regular nor context-free. It turns out that both of the languages are "trick" questions, but in different ways. The first one seems not regular, but on closer inspection it is because there is an "independence" between the variables used. For the second, it's much harder because one must use the "p factorial trick" to show that the language is not regular. To show it isn't context-free, it's very difficult because one needs to see how an "exchange" between parts generated by a a certain context-free grammar can force a difference between the two "halves" of a string.

For more info, check the following videos/playlists:
Pumping lemma: https://www.youtube.com/watch?v=I3FuVKVgLCA&amp;list=PLylTVsqZiRXNuJsZAN-v9VtGFeKZGiP6V
p Factorial trick: https://www.youtube.com/watch?v=neQxf_nYqCs
Context-free grammars: https://www.youtube.com/watch?v=h1OSmLSacNA&amp;list=PLylTVsqZiRXOlDr8PemE5hUTVMGZrLD7G

Timestamps:
0:00 - Intro
1:00 - The two languages
2:11 - Proofs for L1
7:40 - Proof for L2 being regular/not regular
18:10 - Proof of L2 being context-free/not context-free

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:FmX4FEeX_G0</id>
<yt:videoId>FmX4FEeX_G0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #83: Complete Proof of an Inherently Ambiguous Context-Free Language</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=FmX4FEeX_G0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #83: Complete Proof of an Inherently Ambiguous Context-Free Language</media:title>
<media:content url="https://www.youtube.com/v/FmX4FEeX_G0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/FmX4FEeX_G0/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we break the Easy Theory record on the longest "content" video! We prove that a particular context-free language is inherently ambiguous (meaning that every grammar for it is ambiguous, which is deriving some string in at least two ways). The proof is straightforward although technical. We subdivide the proof into 10 sections to assist with moving through the proof. Note that this is a first on Youtube (and other than the paper from which it originates, the only complete one explained on the internet). The original paper is "A Direct Proof of the Inherent Ambiguity of a Simple Context-Free Language" by Maurer, link here: https://dl.acm.org/doi/abs/10.1145/321510.321517.

(Note: there is a "simpler" proof we will eventually show on the channel using a tool called "Ogden's Lemma", but this is a direct and self-contained proof.)

Timestamps:
0:00 - Intro
0:28 - Part 1: What is the language?
4:23 - Part 2: Proof L is context-free
10:13 - Part 3: What is a "reduced" grammar?
17:00 - Part 4: What is an "almost looping" grammar?
20:45 - Part 5: Proof of unambiguous almost looping CFG
32:16 - Part 6: The "Big" Lemma Statement
41:07 - Part 7: Every variable is at least one of the three types
56:40 - Part 8: Every variable is exactly one of the three types
1:02:55 - Part 9: Proving the last two cases
1:09:18 - Part 10: Proving the final theorem

For more information about CFGs and CNF, check out the following playlist:

Context-Free Grammars: https://www.youtube.com/watch?v=h1OSmLSacNA&amp;list=PLylTVsqZiRXOlDr8PemE5hUTVMGZrLD7G

Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:KkiVE49i-Kw</id>
<yt:videoId>KkiVE49i-Kw</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Easy Theory Channel Memberships</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=KkiVE49i-Kw"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Easy Theory Channel Memberships</media:title>
<media:content url="https://www.youtube.com/v/KkiVE49i-Kw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/KkiVE49i-Kw/hqdefault.jpg" width="480" height="360"/>
<media:description>Easy Theory Website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:gFq-eK1ZscY</id>
<yt:videoId>gFq-eK1ZscY</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Easy Theory Channel Trailer</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=gFq-eK1ZscY"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Easy Theory Channel Trailer</media:title>
<media:content url="https://www.youtube.com/v/gFq-eK1ZscY?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/gFq-eK1ZscY/hqdefault.jpg" width="480" height="360"/>
<media:description>Easy Theory Website: https://www.easytheory.org
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:WorgmQH-eko</id>
<yt:videoId>WorgmQH-eko</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>GATE 2019 Question 15 (Discrete Math) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=WorgmQH-eko"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>GATE 2019 Question 15 (Discrete Math) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/WorgmQH-eko?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/WorgmQH-eko/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we will start interspersing exam questions between lecture material so that we can see "real" problems that are actually asked on tests. Here is a problem from GATE 2019 (Question 15) about discrete math, specifically about sets and subsets. We arrive at the answer without knowing the answers in advance. 

Easy Theory Website: https://www.easytheory.org
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:ZGDqiCS4K1s</id>
<yt:videoId>ZGDqiCS4K1s</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #19: The CYK Algorithm (Problem Set #9) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=ZGDqiCS4K1s"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #19: The CYK Algorithm (Problem Set #9) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/ZGDqiCS4K1s?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/ZGDqiCS4K1s/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give two (hard) problems on the CYK algorithm. The main video is here: https://www.youtube.com/watch?v=N8d4kkfxM-s. For more information about CFGs and CNF, check out the following playlists:

Context-Free Grammars: https://www.youtube.com/watch?v=h1OSmLSacNA&amp;list=PLylTVsqZiRXOlDr8PemE5hUTVMGZrLD7G
Chomsky Normal Form: https://www.youtube.com/watch?v=lEsDll4Um7Y&amp;list=PLylTVsqZiRXOKoXo8oPwU3Z3RITt3sb05

Easy Theory Website: https://www.easytheory.org
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:N8d4kkfxM-s</id>
<yt:videoId>N8d4kkfxM-s</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #18: The CYK Algorithm: How does it work? (Dynamic Programming) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=N8d4kkfxM-s"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #18: The CYK Algorithm: How does it work? (Dynamic Programming) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/N8d4kkfxM-s?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/N8d4kkfxM-s/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the infamous CYK algorithm, which is to determine whether or not a context-free grammar (CFG) can generate a string or not. We heavily use the fact that any CFG can be converted into chomsky normal form (CNF), and that we can "build up" a string using many subproblems and scanning through the rules of the grammar. For more information about CFGs and CNF, check out the following playlists:

Context-Free Grammars: https://www.youtube.com/watch?v=h1OSmLSacNA&amp;list=PLylTVsqZiRXOlDr8PemE5hUTVMGZrLD7G
Chomsky Normal Form: https://www.youtube.com/watch?v=lEsDll4Um7Y&amp;list=PLylTVsqZiRXOKoXo8oPwU3Z3RITt3sb05

Easy Theory Website: https://www.easytheory.org
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:1an8nj4NuwM</id>
<yt:videoId>1an8nj4NuwM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Let's Solve Some Problems #3 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=1an8nj4NuwM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Let's Solve Some Problems #3 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/1an8nj4NuwM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/1an8nj4NuwM/hqdefault.jpg" width="480" height="360"/>
<media:description>Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:eUlUzH9fmXQ</id>
<yt:videoId>eUlUzH9fmXQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #86: Chomsky Normal Form Conversion Example (CFG to CNF) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=eUlUzH9fmXQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #86: Chomsky Normal Form Conversion Example (CFG to CNF) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/eUlUzH9fmXQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/eUlUzH9fmXQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give a detailed conversion for an example of converting a context-free grammar (CFG) to Chomsky Normal Form (CNF), with all 5 steps done.

Timestamps:
0:00 - Intro
1:25 - The example grammar
2:47 - Step 1 conversion
3:53 - Step 2 conversion
8:45 - Step 3 conversion
14:10 - Step 4 conversion
17:15 - Step 5 conversion

Easy Theory Website: https://www.easytheory.org
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:lEsDll4Um7Y</id>
<yt:videoId>lEsDll4Um7Y</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #85: Chomsky Normal Form (CFG + CNF conversion), a Correct Proof - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=lEsDll4Um7Y"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #85: Chomsky Normal Form (CFG + CNF conversion), a Correct Proof - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/lEsDll4Um7Y?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/lEsDll4Um7Y/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give a complete and correct proof of Chomsky Normal Form, which is a restricted form of context-free grammars, and the proof is that every CFG can be converted into CNF. Many proofs out there give a "hand-wavy" argument, but we give a technically sound argument at each step of the way. There are 5 stages - watch the video to find out what the 5 are!

Timestamps:
0:00 - Intro
3:00 - Definition of Chomsky Normal Form
7:30 - Proof of Step 1's correctness
12:15 - Proof of Step 2's correctness
20:20 - Proof of Step 3's correctness
27:13 - Proof of Step 4's correctness
30:42 - Proof of Step 5's correctness

Easy Theory Website: https://www.easytheory.org
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:W1qo44hA1rU</id>
<yt:videoId>W1qo44hA1rU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Proof by Contradiction (Problem Set #8)- Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=W1qo44hA1rU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Proof by Contradiction (Problem Set #8)- Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/W1qo44hA1rU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/W1qo44hA1rU/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give two problems related to proof by contradiction.

Easy Theory Website: https://www.easytheory.org
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:i9KTtaKjGac</id>
<yt:videoId>i9KTtaKjGac</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Proof by Contradiction (+ Examples!) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=i9KTtaKjGac"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Proof by Contradiction (+ Examples!) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/i9KTtaKjGac?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/i9KTtaKjGac/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we introduce the idea of proof by contradiction, which is a technique of proving that the opposite of a claim cannot possibly be true (by deriving a contradiction). We show that sqrt(2) cannot be rational, and that there are no integers p, q such that p^2 - 4q = 2.

Easy Theory Website: https://www.easytheory.org
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:1-c9IxpFZvk</id>
<yt:videoId>1-c9IxpFZvk</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #17: Longest Increasing Subsequence - Problem Set #7 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=1-c9IxpFZvk"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #17: Longest Increasing Subsequence - Problem Set #7 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/1-c9IxpFZvk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/1-c9IxpFZvk/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give two problems about the longest increasing subsequence problem. Note: there actually is an answer to Question 1 that I didn't know when filming, but I still want you to work it out in the comments.

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:ggUN8TijNiU</id>
<yt:videoId>ggUN8TijNiU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #16: Longest Increasing Subsequence + Dynamic Programming - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=ggUN8TijNiU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #16: Longest Increasing Subsequence + Dynamic Programming - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/ggUN8TijNiU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/ggUN8TijNiU/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we introduce the "longest increasing subsequence" problem, which is, given an array A, try to find the longest length of any subset of A that is strictly increasing. I do an example in the video. It's easily shown then that the LIS problem can be solved in O(2^n) time by examining every subset. However, we can use dynamic programming here by noticing that "close" subsets are not going to have wildly different LIS values. So we develop a recurrence for the LIS problem, and then make an "iterative" algorithm that saves previous calculations in a table. We then show that it can be solved in O(n^2) time. 

Chapters:
0:00 - Intro
0:39 - What is the problem?
5:04 - Brute force algorithm
10:05 - Can we go faster?
12:39 - Defining the recurrence
22:09 - How the memoization works here
22:57 - Iterative algorithm
33:05 - What is the runtime of the DP algorithm?

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:o64uz2K2S4E</id>
<yt:videoId>o64uz2K2S4E</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #82: Context-Free Grammar Definitions (Yields, Ambiguous, Leftmost Derivation)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=o64uz2K2S4E"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #82: Context-Free Grammar Definitions (Yields, Ambiguous, Leftmost Derivation)</media:title>
<media:content url="https://www.youtube.com/v/o64uz2K2S4E?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/o64uz2K2S4E/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we are doing a bonus video about context-free grammars (CFGs): yields, ambiguous, and leftmost derivation. They will all be important in upcoming videos. Yields involves the application of a single rule, and a derivation is a sequence of yields operations to yield a string that is only consisting of terminals. A leftmost derivation is one where the leftmost variable is always the one that is replaced. Ambiguous grammars are those that have some string they make that has 2 different leftmost derivations. A language is inherently ambiguous if every CFG for it is ambiguous.

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:COTzXfoaGpM</id>
<yt:videoId>COTzXfoaGpM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #79: Context-Free Grammar (CFG) - Problem Set #6 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=COTzXfoaGpM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #79: Context-Free Grammar (CFG) - Problem Set #6 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/COTzXfoaGpM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/COTzXfoaGpM/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give two problems related to context-free grammars and context-free languages. 

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:h1OSmLSacNA</id>
<yt:videoId>h1OSmLSacNA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #78: What is a Context-Free Grammar (CFG)? Context-Free Language (CFL)?</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=h1OSmLSacNA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #78: What is a Context-Free Grammar (CFG)? Context-Free Language (CFL)?</media:title>
<media:content url="https://www.youtube.com/v/h1OSmLSacNA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/h1OSmLSacNA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we start a new set of material, namely on context-free grammars (CFG) and context-free languages (CFL), which are the languages of CFGs. The idea is to have every rule's right-hand side allowed to have any combination of variables and terminals. We show that every regular grammar is already a context-free grammar, and not necessarily the other way around because we give an example of a CFG for {0^n 1^n : n at least 0}, which is not regular. We then make a CFG for the language of palindromes over {0,1}.

Timestamps:
0:00 - Intro
0:35 - Grammars (generally)
2:35 - Example grammar that has nonregular language
7:45 - Context-Free Grammar (CFG) definition
11:15 - Example CFG for Palindromes

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:YCBFeF8aqgU</id>
<yt:videoId>YCBFeF8aqgU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Proof by Cases Example + Problem Set #5 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=YCBFeF8aqgU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Proof by Cases Example + Problem Set #5 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/YCBFeF8aqgU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/YCBFeF8aqgU/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do another example of proof by cases, mainly in showing that 2n^2 + n + 1 is not a multiple of 3. The cases here are all the "equivalence classes" of division by 3, namely "what is the remainder when divided by 3?" Here, those are 0, 1, and 2. We split the statement up into these three cases, and then prove each one of them separately.

Can this proof be done directly, without cases?

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:eD9a3IyiLe4</id>
<yt:videoId>eD9a3IyiLe4</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Proof by Cases - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=eD9a3IyiLe4"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Proof by Cases - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/eD9a3IyiLe4?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/eD9a3IyiLe4/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we introduce "proof by cases", which involves splitting a proposition into multiple cases, and then proving each one of the cases using (possibly) different logic. The example we do here is simple, but the idea is what is important (and how to solve the problem set as well).

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:O-iWiiy18Sw</id>
<yt:videoId>O-iWiiy18Sw</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #15: Dynamic Programming - Problem Set #4 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=O-iWiiy18Sw"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #15: Dynamic Programming - Problem Set #4 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/O-iWiiy18Sw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/O-iWiiy18Sw/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give some problems about dynamic programming. 

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:OF_cTYUIHN0</id>
<yt:videoId>OF_cTYUIHN0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #14: What is Dynamic Programming? Smart Recursion! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=OF_cTYUIHN0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #14: What is Dynamic Programming? Smart Recursion! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/OF_cTYUIHN0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/OF_cTYUIHN0/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we introduce the idea of "smart recursion", which is better known as "dynamic programming". We illustrate this with the calculation of the Fibonacci numbers, which give a horrendously slow algorithm if we don't keep previous calculations stored (i.e., we will repeat them). So we use "smart" recursion by saving calculations in a table, leading to a much faster algorithm.

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Mq8g1r-9V2Y</id>
<yt:videoId>Mq8g1r-9V2Y</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Creating the Easy Theory Website #1 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Mq8g1r-9V2Y"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Creating the Easy Theory Website #1 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Mq8g1r-9V2Y?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Mq8g1r-9V2Y/hqdefault.jpg" width="480" height="360"/>
<media:description>Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:9bbnztdJqQQ</id>
<yt:videoId>9bbnztdJqQQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Let's Solve Some Problems #2 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=9bbnztdJqQQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Let's Solve Some Problems #2 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/9bbnztdJqQQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/9bbnztdJqQQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:EH0JZp0D3UI</id>
<yt:videoId>EH0JZp0D3UI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #76: Regular Grammars (Problem Set #3) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=EH0JZp0D3UI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #76: Regular Grammars (Problem Set #3) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/EH0JZp0D3UI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/EH0JZp0D3UI/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give some problems on regular grammars, that deal with the conversions between them and NFAs and DFAs, such as how big the regular grammar and/or NFA/DFA will be, and is there a direct conversion between a regular grammar and DFA (without using an intermediate NFA)?

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:fQVZ3B7qi6w</id>
<yt:videoId>fQVZ3B7qi6w</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #75: What is a Regular Grammar? NFA to Regular Grammar conversion also!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=fQVZ3B7qi6w"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #75: What is a Regular Grammar? NFA to Regular Grammar conversion also!</media:title>
<media:content url="https://www.youtube.com/v/fQVZ3B7qi6w?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/fQVZ3B7qi6w/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at "regular grammars", which are a type of grammar where the rules are heavily restricted. Only four types of rules are allowed. We also show how to convert from any NFA into an equivalent regular grammar, and vice versa. Both proofs are similar because the first one is a "1 to 1" conversion, meaning that "nothing is lost" during it, and so therefore can be reversed.

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Timestamps:
0:00 - Intro
0:40 - What is a regular grammar?
4:00 - Regular Grammar to NFA conversion
13:30 - DFA/NFA to Regular Grammar conversion

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:NWyh8Eug7QM</id>
<yt:videoId>NWyh8Eug7QM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #74: What are Grammars? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=NWyh8Eug7QM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #74: What are Grammars? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/NWyh8Eug7QM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/NWyh8Eug7QM/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at a "grammar", which is a way of formally generating strings. We saw with DFA/NFAs that they can recognize whether a string is in the language, and a regular expression describes a language. The grammar has a set of rules that one can apply from the "start variable", to hopefully get a string entirely of terminals.

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:AF7cc_9j_tk</id>
<yt:videoId>AF7cc_9j_tk</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Direct Proofs (Problem Set #2) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=AF7cc_9j_tk"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Direct Proofs (Problem Set #2) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/AF7cc_9j_tk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/AF7cc_9j_tk/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give some problems to work on involving direct proofs, as well as finding a counterexample to a given claim. We also introduce "if and only if", and how to solve claims that involve that.

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:jNCH5fWR8rM</id>
<yt:videoId>jNCH5fWR8rM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Direct Proofs - how do you do it? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=jNCH5fWR8rM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Direct Proofs - how do you do it? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/jNCH5fWR8rM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/jNCH5fWR8rM/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show the concept of a "proof", and give a simple one to prove that every rational number * 2 is also a rational number. I also give some guidelines on how to approach other proofs, and how to approach them step-by-step. Proof writing is very important, and being able to fully convince the proof reader that every step is correct is a vital part of succeeding in discrete mathematics, and computer science in general.

Timestamps:
0:00 - Intro
1:20 - Recap on Quantifiers
2:10 - Recap on Q (rationals)
2:55 - What is a Theorem? Lemma? Corollary?
5:20 - Statement of Lemma
6:05 - What you should pay attention to
6:35 - Start of proof
7:05 - Single examples don't suffice
8:03 - Let x be any rational number
9:19 - Definitions = friends
9:52 - Applying the definition
10:23 - Calculating 2*x
11:17 - Showing that 2*x is a rational number
12:25 - End of proof
13:18 - Conclusion

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Image taken from: https://www.picpedia.org/chalkboard/p/proof.html

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:ekh7ITxtoTQ</id>
<yt:videoId>ekh7ITxtoTQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #13: Linear Time Median Problem Set #1 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=ekh7ITxtoTQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #13: Linear Time Median Problem Set #1 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/ekh7ITxtoTQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/ekh7ITxtoTQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we start a new series that on Tuesdays, Thursdays, and Saturdays, we will have "problem sets" for you to work on. I present several problems, and you solve them in the comments.

This problem set is about the linear time median algorithm video (link in the card), and some variants of the algorithm that I would like you to solve, or to show is impossible.

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:n8cyxDtp9t4</id>
<yt:videoId>n8cyxDtp9t4</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #12: Linear-Time Median Algorithm (Making Quicksort go Fast!) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=n8cyxDtp9t4"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #12: Linear-Time Median Algorithm (Making Quicksort go Fast!) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/n8cyxDtp9t4?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/n8cyxDtp9t4/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that we can find the median of an array (or in general, the kth smallest element) in linear time, versus just sorting the array and returning the kth element. This in turn speeds up Quicksort, because the pivot can now be the median element (findable in linear time), and we now get the guaranteed performance of Mergesort, which was O(n log n). Before, Quicksort can at worst pick the "first" element every time, which caused a O(n^2) runtime to occur.

Timestamps:
0:00 - Intro
0:31 - Problem Statement
3:28 - Can we find a good pivot?
6:37 - Generalize the problem (finding kth smallest/largest)
7:45 - Kth Smallest/Largest "Simple" Recursive Algorithm
13:25 - Can we make this algorithm faster?
15:10 - Median of Medians
20:50 - Modifying Kth Smallest/Largest Algorithm
24:55 - Proving this algorithm is faster
29:00 - Determining algorithm runtime

Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:0k9iz6AaPzQ</id>
<yt:videoId>0k9iz6AaPzQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Let's Solve Some Problems #1 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=0k9iz6AaPzQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Let's Solve Some Problems #1 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/0k9iz6AaPzQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/0k9iz6AaPzQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:zmdkr4BMqR4</id>
<yt:videoId>zmdkr4BMqR4</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #73: What is the Myhill-Nerode Equivalence Relation? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=zmdkr4BMqR4"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #73: What is the Myhill-Nerode Equivalence Relation? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/zmdkr4BMqR4?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/zmdkr4BMqR4/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the Myhill-Nerode Equivalence Relation, which is another way of proving a language is not regular. Some languages cannot be shown to be regular using the pumping lemma, so we look at a "stronger" property, which is that if two different strings land in the same state, then anything read after either of them will also result in the same state. We use this on its head by considering any two different strings xz and yz that land in different states, then it must be that x and y themselves went to different states. If there are infinitely many such cases, this implies that the language cannot be regular.

#easytheory #gate #theory

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:XiCnd54V1NE</id>
<yt:videoId>XiCnd54V1NE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>What are Quantifiers? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=XiCnd54V1NE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>What are Quantifiers? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/XiCnd54V1NE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/XiCnd54V1NE/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at "quantifiers", which are ways of saying when a statement is true by telling a "range" of when the variable should be used. We have two quantifiers: "forall", and "exists". The first says that the statement is true for all values of the variable (over the given domain), and the second says that it is true for *some* value of the variable. We show how different domains as well as different quantifiers can make a statement true or false.

#easytheory #gate #theory

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:TVpzeF3qQ0g</id>
<yt:videoId>TVpzeF3qQ0g</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Ask the Professor #3 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=TVpzeF3qQ0g"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Ask the Professor #3 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/TVpzeF3qQ0g?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/TVpzeF3qQ0g/hqdefault.jpg" width="480" height="360"/>
<media:description>DONATE (appears on stream): https://streamlabs.com/easytheory1/tip

Contribute in other ways:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easyt...
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierar...
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-f...

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY...

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:rP5peOkXsbY</id>
<yt:videoId>rP5peOkXsbY</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #9: Asymptotic Analysis and Runtime - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=rP5peOkXsbY"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #9: Asymptotic Analysis and Runtime - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/rP5peOkXsbY?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/rP5peOkXsbY/hqdefault.jpg" width="480" height="360"/>
<media:description>Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Chapters:
0:00 - Intro
1:10 - Asymptotic Analysis
5:56 - Big-O, Big-Omega, Big-Theta
12:59 - Asymptotic Runtime
17:46 - Solving the runtime for Mergesort and Quicksort
27:59 - Solving the runtime for Towers of Hanoi
34:07 - Conclusion

Here we look at asymptotic analysis, which will help us analyze the runtime of algorithms in a more formal way, and we solve the runtime of both the merge and quick sort algorithms (assuming a good pivot for quick sort), as well as the Towers of Hanoi algorithm. 

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:qqPcKqmAM-E</id>
<yt:videoId>qqPcKqmAM-E</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Solving My Theory Exams Livestream #1 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=qqPcKqmAM-E"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Solving My Theory Exams Livestream #1 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/qqPcKqmAM-E?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/qqPcKqmAM-E/hqdefault.jpg" width="480" height="360"/>
<media:description>Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

#easytheory #gate #theory

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:I3FuVKVgLCA</id>
<yt:videoId>I3FuVKVgLCA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #63: Pumping Lemma FOUR Examples and proof Strategies (Regular Languages)!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=I3FuVKVgLCA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #63: Pumping Lemma FOUR Examples and proof Strategies (Regular Languages)!</media:title>
<media:content url="https://www.youtube.com/v/I3FuVKVgLCA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/I3FuVKVgLCA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do four proofs of languages not being regular using the pumping lemma for regular languages, as well as give a proof strategy. The basic idea is to suppose that the language is indeed regular. Then the lemma asserts that a pumping constant "p" for that language exists. Then pick a string (chosen carefully) that is in the language and of length at least p. After observing all possible decompositions of that string into three pieces x, y, z (according to the rules), we choose a value of i such that xy^iz is not in the language. The video about the pumping lemma's proof is here: https://www.youtube.com/watch?v=A5FiVgd0QyQ.

We do four different languages by showing slightly different variations on the theme of proof outlined above, shown in the chapters below:

0:00 - Introduction
1:30 - General Proof Strategy
7:05 - {0^n 1^n : n at least 0}
17:22 - {0^i 1^j : i strictly larger than j}
25:18 - {0^n : n is a perfect square}
34:18 - {0^n : n is a prime number}
44:56 - Conclusion

#easytheory #gate #theory

Contribute:
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:reuj-HIDx0o</id>
<yt:videoId>reuj-HIDx0o</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Logical Equivalences (+ De Morgan's Laws) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=reuj-HIDx0o"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Logical Equivalences (+ De Morgan's Laws) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/reuj-HIDx0o?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/reuj-HIDx0o/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we take a short look at logical equivalences, which are statements that are logically the same as the other. We then stumble upon De Morgan's laws, which are really useful in that they can "distribute" a negation across an AND or an OR of two propositions. We give brief reasons why each of the equivalences is true.

#easytheory #discretemath #theory

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:1wRTqxeHtiw</id>
<yt:videoId>1wRTqxeHtiw</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #8: Quicksort Algorithm EXAMPLE - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=1wRTqxeHtiw"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #8: Quicksort Algorithm EXAMPLE - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/1wRTqxeHtiw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/1wRTqxeHtiw/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do an example of the quicksort algorithm in its entirety; the main video is here: https://www.youtube.com/watch?v=bDM-OCeynfQ

#easytheory #gate #theory

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:bDM-OCeynfQ</id>
<yt:videoId>bDM-OCeynfQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #7: The Quicksort Algorithm + more Recursion! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=bDM-OCeynfQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #7: The Quicksort Algorithm + more Recursion! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/bDM-OCeynfQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/bDM-OCeynfQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the quicksort algorithm, which is another sorting algorithm that uses recursion. The idea is that it is very similar to mergesort, but instead of recursively working on the two halves and then merging, we first "split" the array into two pieces, and *then* recursively work on the two pieces. The idea is to pick a "pivot" element, and to move all of the other elements to the "correct side" of this pivot element. The two halves are just the partition created by this pivot.

#easytheory #gate #theory

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:3SKSG7Ryoi0</id>
<yt:videoId>3SKSG7Ryoi0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>6-Month Progress Report - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=3SKSG7Ryoi0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>6-Month Progress Report - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/3SKSG7Ryoi0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/3SKSG7Ryoi0/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give a progress report on the Easy Theory channel after 6 months. Currently we are at around 3.1 thousand subscribers, and 63 thousand total video views. Finally, we have about 2.6 thousand total hours of watched content. I show some more analytics of the channel, including impressions and geography.

#easytheory #gate #theory

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:A5FiVgd0QyQ</id>
<yt:videoId>A5FiVgd0QyQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #61: Pumping Lemma for Regular Languages PROOF - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=A5FiVgd0QyQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #61: Pumping Lemma for Regular Languages PROOF - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/A5FiVgd0QyQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/A5FiVgd0QyQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give a proof of the pumping lemma for regular languages, one of the most important results in the entire class. The idea stems from what we did last time, in that we can prove that "other" strings exist in a given language provided that it is regular. We classify what those other strings' properties must have, and criteria in order to use the pumping lemma. It isn't useful in that it cannot help us prove that languages are regular, but it will help in proving languages are *not* regular.

#easytheory #gate #theory

Chapters:
0:00 - Introduction
1:30 - Can we guarantee a loop?
4:00 - Strings of length n see n+1 states
7:55 - Pumping Lemma statement
15:00 - Three properties of the Pumping Lemma

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:RDOZ7o82TgU</id>
<yt:videoId>RDOZ7o82TgU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #60: Are there Non-Regular Languages? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=RDOZ7o82TgU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #60: Are there Non-Regular Languages? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/RDOZ7o82TgU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/RDOZ7o82TgU/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we investigate the question of whether there exist non-regular languages by looking at a different question: if a "long" string in a DFA is accepted, can we infer any other information about other strings in the DFA also being accepted?

#easytheory #gate #theory

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:kG-qM5dyj9Y</id>
<yt:videoId>kG-qM5dyj9Y</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Logic: Propositions, Implication, Converse + Contrapositive - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=kG-qM5dyj9Y"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Logic: Propositions, Implication, Converse + Contrapositive - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/kG-qM5dyj9Y?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/kG-qM5dyj9Y/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we talk about propositions and implication in discrete mathematics. They are statements that by themselves are either True (T) or False (F). We can form "compound" statements with AND or OR. But one of the more important ones is "implication", where one proposition implies another one. We discuss truth tables, as well as converse, bidirectional (i.e., "if and only if"), and contrapositive propositions. We give a short proof that propositions are equivalent to their contrapositives (at least in a logical sense).

#easytheory #gate #theory

Chapters:
0:00 Introduction
1:31 Propositions
4:30 AND
6:20 OR
8:00 Truth Tables
12:00 Implication
18:43 Other Types of Implication
22:00 Proof that Contrapositive Equivalent to Original


Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:qjB7JEC05MA</id>
<yt:videoId>qjB7JEC05MA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #6: Merge Sort EXAMPLE - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=qjB7JEC05MA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #6: Merge Sort EXAMPLE - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/qjB7JEC05MA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/qjB7JEC05MA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do an example of Merge Sort - the main video is here: https://youtu.be/XsTgN-jKMUQ

#easytheory #gate #theory

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:XsTgN-jKMUQ</id>
<yt:videoId>XsTgN-jKMUQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #5: Merge Sort, Explained - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=XsTgN-jKMUQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #5: Merge Sort, Explained - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/XsTgN-jKMUQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/XsTgN-jKMUQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we continue with recursion about merge sort, which is a recursive algorithm to sort a list. The idea is to define recursive cases as being a sorted "smaller" version of the list, and to have multiple pieces of the list that are sorted individually. Then, we "merge" the multiple pieces together to sort the whole list. The base case here is when we have 1 element, which is always sorted.

#easytheory #gate #theory

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:vZgsEmJjJXU</id>
<yt:videoId>vZgsEmJjJXU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>100 MORE Algorithm Exam Solutions (GATE, UGC-NET, ISRO/DRDO, CIL, TNPSC) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=vZgsEmJjJXU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>100 MORE Algorithm Exam Solutions (GATE, UGC-NET, ISRO/DRDO, CIL, TNPSC) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/vZgsEmJjJXU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/vZgsEmJjJXU/hqdefault.jpg" width="480" height="360"/>
<media:description>DONATE (appears on stream): https://streamlabs.com/easytheory1/tip

Questions are here: https://solutionsadda.in/subject/?cs=Algorithms

Chapters:
0:00:00 - Start of recording
0:19:10 - Stream starts
0:28:49 - Questions 101 to 110
0:48:39 - Questions 111 to 120
1:12:19 - Questions 121 to 130
1:40:05 - Questions 131 to 140
2:07:20 - Questions 141 to 150
2:20:21 - Questions 151 to 160
2:30:37 - Questions 161 to 170
2:47:56 - Questions 171 to 180
3:02:24 - Questions 181 to 190
3:17:58 - Questions 191 to 200

Contribute in other ways:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierar...
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-f...

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY...

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:trBbpsaPkbc</id>
<yt:videoId>trBbpsaPkbc</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #59: Arden's Theorem/Lemma PROOF - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=trBbpsaPkbc"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #59: Arden's Theorem/Lemma PROOF - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/trBbpsaPkbc?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/trBbpsaPkbc/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we prove Arden's Theorem/Lemma, which says that if we have regexes A and B such that (1) epsilon is not in A, and (2) A = C U AB for some regex C, then we can uniquely write A as CB*. The idea is to "expand" out the right side until we notice a pattern, and then factor C out of the right side. Then we use the definition of star to deduce that it is indeed CB*.

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy     

▶ADDITIONAL QUESTIONS◀
1. Prove that A = CB* is unique.

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:MZDiriNRAVA</id>
<yt:videoId>MZDiriNRAVA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Math Basics for Theory - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=MZDiriNRAVA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Math Basics for Theory - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/MZDiriNRAVA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/MZDiriNRAVA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we cover some "basic" mathematical concepts that are used a lot in theory, such as exponentials, commonly used sets, logarithms, and more. This is a "primer" video for the "Discrete Math" lecture series, here: https://www.youtube.com/playlist?list=PLylTVsqZiRXMQUrrx2_JOt75SAd8fhHEh

#easytheory #gate #theory

Chapters:
0:00 - Intro
0:57 - Sets
1:35 - Set Examples (Integers, Naturals, etc.)
6:58 - Intervals (Closed, Open, Half-Open)
10:23 - Ordered Pairs
12:13 - Exponentials and Logarithms
19:51 - Other Functions (Factorial, Floor, Ceiling)
22:23 - Summations

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:3J9TbapCD8I</id>
<yt:videoId>3J9TbapCD8I</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Ask the Professor #2 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=3J9TbapCD8I"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Ask the Professor #2 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/3J9TbapCD8I?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/3J9TbapCD8I/hqdefault.jpg" width="480" height="360"/>
<media:description>DONATE (appears on stream): https://streamlabs.com/easytheory1/tip

Contribute in other ways:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easyt...
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierar...
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-f...

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY...

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:svjqkfdhIQI</id>
<yt:videoId>svjqkfdhIQI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #4: Towers of Hanoi EXAMPLE - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=svjqkfdhIQI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #4: Towers of Hanoi EXAMPLE - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/svjqkfdhIQI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/svjqkfdhIQI/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do an example of the Towers of Hanoi problem with 3 pegs. The main video for this is here: https://www.youtube.com/watch?v=Hd0EekdmpKA

#easytheory #gate #theory

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Hd0EekdmpKA</id>
<yt:videoId>Hd0EekdmpKA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #3: Towers of Hanoi using RECURSION TWICE! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Hd0EekdmpKA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #3: Towers of Hanoi using RECURSION TWICE! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Hd0EekdmpKA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Hd0EekdmpKA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the "Towers of Hanoi" problem, which involves using recursion twice. We have to move n cylinders of different sizes from one peg to another, utilizing a third one if necessary, and such that no "bigger" cylinder is on top of a smaller cylinder at any point. What we can do is to define inductive cases really easily, and then solve the whole problem by just relating the two recursive "moves" of n-1 cylinders to each other.

An example worked out is here: https://www.youtube.com/watch?v=svjqkfdhIQI

#easytheory #gate #theory

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:rcjR3--M7iM</id>
<yt:videoId>rcjR3--M7iM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #58: Regex to DFA Directly Using Brzozowski Derivatives (No NFA) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=rcjR3--M7iM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #58: Regex to DFA Directly Using Brzozowski Derivatives (No NFA) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/rcjR3--M7iM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/rcjR3--M7iM/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show, with an example, that one can create a DFA directly from a regular expression using Brzozowski Derivatives. Therefore, no NFA is ever needed to do the conversion. We first set the start state to be the original regex, and its transitions correspond to taking partial derivatives of that regex with each of the input characters. If a new regex is formed that hasn't been seen before, then that transition goes to a new state. This is repeated until no new states are formed, and the final states are ones that can make the empty string (epsilon).

The original video is here: https://www.youtube.com/watch?v=s9EPoy9r-ok

#easytheory #gate #theory

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Y1g6JTBvqms</id>
<yt:videoId>Y1g6JTBvqms</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Discrete Mathematics (Overview) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Y1g6JTBvqms"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Discrete Mathematics (Overview) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Y1g6JTBvqms?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Y1g6JTBvqms/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we start a new series on "Discrete Mathematics", and give an overview of what we will be covering in the series.

Contribute:
Donation (appears on streams): https://streamlabs.com/easytheory1/tip
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:b0_S0X1JwGk</id>
<yt:videoId>b0_S0X1JwGk</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #2: Multiplying x * y Using RECURSION - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=b0_S0X1JwGk"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #2: Multiplying x * y Using RECURSION - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/b0_S0X1JwGk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/b0_S0X1JwGk/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we determine how to multiply x and y using recursion. It's a simple idea, by solving a simpler version of the same problem, until we reach a "base" case that we definitely know the answer to (i.e., when one of x and y is 0). However, this idea is very deep in that many problems that use recursion utilize the same basic structure: base cases, and "inductive" cases (a fancy term for "smaller" version of the same problem that you can combine to solve the whole problem).

#easytheory #gate #theory

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:sT3ImMy0fRE</id>
<yt:videoId>sT3ImMy0fRE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Algorithms #1: What's an Algorithm? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=sT3ImMy0fRE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Algorithms #1: What's an Algorithm? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/sT3ImMy0fRE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/sT3ImMy0fRE/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we start our Algorithms Lecture series on understanding what an algorithm is - a sequence of instructions that when executed always runs in a finite amount of time (as oppose to a procedure which doesn't make this guarantee). We do a simple example of why algorithms are necessary: inputs need to be specified, the steps given in a precise way, and more. 

#easytheory #gate #theory

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:gqLr_ZYpVp0</id>
<yt:videoId>gqLr_ZYpVp0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Ask the Professor #1 - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=gqLr_ZYpVp0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Ask the Professor #1 - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/gqLr_ZYpVp0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/gqLr_ZYpVp0/hqdefault.jpg" width="480" height="360"/>
<media:description>#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:P9FtoOCZMDM</id>
<yt:videoId>P9FtoOCZMDM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #57: Derivative of a Regex?! EXAMPLE (Brzozowski Derivative) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=P9FtoOCZMDM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #57: Derivative of a Regex?! EXAMPLE (Brzozowski Derivative) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/P9FtoOCZMDM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/P9FtoOCZMDM/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give two examples of derivatives of regexes, and show that the corresponding string can be generated by the regex by repeatedly applying the derivative. This has the advantage of not having to generate the NFA/DFA in order to check if the string is accepted. The main video is here: https://youtu.be/s9EPoy9r-ok

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy      

▶ADDITIONAL QUESTIONS◀
1. Can you formally prove that epsilon is not generated by the ending regex?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:s9EPoy9r-ok</id>
<yt:videoId>s9EPoy9r-ok</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #56: Derivative of a Regex?! (Brzozowski Derivative) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=s9EPoy9r-ok"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #56: Derivative of a Regex?! (Brzozowski Derivative) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/s9EPoy9r-ok?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/s9EPoy9r-ok/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we introduce the idea of a "derivative" of a regular expression (regex). The idea is to "divide" out the string that you're using out of the strings that are generated by the regex. We give a definition of what a derivative of a language is, and prove that the properties hold when considering a regex. The purpose of these derivatives (called "Brzozowski Derivatives") is that one can determine whether or not a regex can generate a string by repeatedly applying a derivative to each character of the string.

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters:  Micah Wood
Silver Supporters: Timmy Gy     

▶ADDITIONAL QUESTIONS◀
1. What if we permitted additional operations for regexes, such as complement or intersection?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:u_R0tZAnTi4</id>
<yt:videoId>u_R0tZAnTi4</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #55: The "General" General NFA Method (NFA to Regex, GNFA) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=u_R0tZAnTi4"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #55: The "General" General NFA Method (NFA to Regex, GNFA) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/u_R0tZAnTi4?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/u_R0tZAnTi4/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we introduce the idea of a "generalized" general NFA method, which we call the GGNFA method. The idea is that we can generate a regex for any size NFA without having to do the conversion ourselves. We motivate this with a 3-state NFA, and are able to derive a regex that represents all possible languages that an NFA with 3 states can recognize. If we have an actual NFA we want a regex for, we just "plug in" to the "general" regex we have and then automatically get one for free. This method generalizes to any number of states and any alphabet.

The main video on the conversion and its proof is here: https://youtu.be/HUolNKq7v3k

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶ADDITIONAL QUESTIONS◀
1. Try (if you dare!) to derive the regex for 4 or more states ;)
2. If I have a regex R for n states, can I get one for n+1 states from R?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Gfa3WUFVsJA</id>
<yt:videoId>Gfa3WUFVsJA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #54: NFA to Regex Conversion Example #2 (More Complicated, GNFA Method)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Gfa3WUFVsJA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #54: NFA to Regex Conversion Example #2 (More Complicated, GNFA Method)</media:title>
<media:content url="https://www.youtube.com/v/Gfa3WUFVsJA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Gfa3WUFVsJA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give a slightly more complicated example on the NFA to regex conversion that uses nondeterminism. The main video of this method is here: https://youtu.be/HUolNKq7v3k

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy   

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:hJy6nUPtfts</id>
<yt:videoId>hJy6nUPtfts</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>100 Algorithm CS Exam Questions SOLVED (GATE, UGC-NET, ISRO/DRDO, CIL, TNPSC) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=hJy6nUPtfts"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>100 Algorithm CS Exam Questions SOLVED (GATE, UGC-NET, ISRO/DRDO, CIL, TNPSC) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/hJy6nUPtfts?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/hJy6nUPtfts/hqdefault.jpg" width="480" height="360"/>
<media:description>Here is a livestream of over 300 ALGORITHM computer science exam questions, all solved in a row. They include all GATE exam questions, UGC-NET, ISRO/DRDO, CIL, TNPSC, and TIFR PHD &amp; SS. 

The questions are all here: https://solutionsadda.in/subject/?cs=Algorithms

0:00:00 - Intro
0:10:00 - Stream starts
0:20:29 - Problems 1 to 10
0:55:02 - Problems 11 to 20
1:21:00 - Problems 21 to 30
1:51:28 - Problems 31 to 40
2:30:42 - Problems 41 to 50
2:55:11 - Problems 51 to 60
3:09:06 - Problems 61 to 70
3:17:43 - Problems 71 to 80
3:20:30 - Problems 81 to 90
3:26:18 - Problems 91 to 100

#easytheory #algorithms #gate

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:kwKj0GYTSag</id>
<yt:videoId>kwKj0GYTSag</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>300+ Theory CS Exam Questions SOLVED (GATE, UGC-NET, ISRO/DRDO, CIL, TNPSC) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=kwKj0GYTSag"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>300+ Theory CS Exam Questions SOLVED (GATE, UGC-NET, ISRO/DRDO, CIL, TNPSC) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/kwKj0GYTSag?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/kwKj0GYTSag/hqdefault.jpg" width="480" height="360"/>
<media:description>Here is a livestream of over 500 THEORY computer science exam questions, all solved in a row. They include all GATE exam questions, UGC-NET, ISRO/DRDO, CIL, TNPSC, and TIFR PHD &amp; SS. 

All of the questions can be found here: https://solutionsadda.in/subject/?cs=Theory-of-Computation

#easytheory #gate #theoryofcomputing 

Chapters:
0:00:00 - Start
0:14:41 - 250 through 299
1:37:09 - 300 through 349
2:35:44 - 350 through 399
3:35:29 - 400 through 449
4:28:05 - 450 through 499
5:50:13 - 500 through 549
6:35:38 - 550 through 575

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:nCsY0LBuE_4</id>
<yt:videoId>nCsY0LBuE_4</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #53: NFA to Regex Conversion Example #1, "Simple" (3-State DFA, GNFA Method)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=nCsY0LBuE_4"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #53: NFA to Regex Conversion Example #1, "Simple" (3-State DFA, GNFA Method)</media:title>
<media:content url="https://www.youtube.com/v/nCsY0LBuE_4?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/nCsY0LBuE_4/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do a simple example of the GNFA method, which involves conversion of an NFA to an equivalent regex. The main video is here: https://youtu.be/HUolNKq7v3k

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy  

▶ADDITIONAL QUESTIONS◀
1. Is there a "better" choice of states to rip?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:HUolNKq7v3k</id>
<yt:videoId>HUolNKq7v3k</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #52: NFA to Regex PROOF (GNFA Method) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=HUolNKq7v3k"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #52: NFA to Regex PROOF (GNFA Method) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/HUolNKq7v3k?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/HUolNKq7v3k/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show how to convert any NFA into an equivalent regex, called the "GNFA Method". This idea "rips" states out of an NFA until we get down to a two-state "NFA" with a single regex on the only transition (from the single start state to the single final state). An NFA cannot have a regex on the transition, so we define a "generalized" NFA (GNFA) which does allow them. Then the ripping states part becomes easy, as explained in the video.

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy      

▶ADDITIONAL QUESTIONS◀
1. Can we add the "empty set" transitions involving the start and final state?
2. Is there a way to rip states while maintaining the original final states as being final?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:c-IoxIZFeRQ</id>
<yt:videoId>c-IoxIZFeRQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #51: Regular Expression (Regex) to NFA example - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=c-IoxIZFeRQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #51: Regular Expression (Regex) to NFA example - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/c-IoxIZFeRQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/c-IoxIZFeRQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give an example on the regular expression (regex) to NFA proof we did in the last video, which is here: https://www.youtube.com/watch?v=HLOAwCCYVxE&amp;list=PLylTVsqZiRXN3Q86XJV6OWOmIzvVZs75E&amp;index=33

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy  

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:HLOAwCCYVxE</id>
<yt:videoId>HLOAwCCYVxE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #50: Regular Expression (Regex) to NFA Conversion - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=HLOAwCCYVxE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #50: Regular Expression (Regex) to NFA Conversion - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/HLOAwCCYVxE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/HLOAwCCYVxE/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we cover the regular expression (regex) to NFA conversion. The idea is to revisit the definition of regex, and to make an NFA for each of the 6 pieces of the definition. For the first three, we can make either a 1-state or a 2-state NFA. For the other three (the "inductive" cases), we revisit earlier constructions with NFAs using union, concatenation, and star to make an NFA for the "bigger" regex, using "smaller" NFAs that have already been built.

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy  

▶ADDITIONAL QUESTIONS◀
1. What does the NFA for the regex ab look like?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:3sRaP3agFU4</id>
<yt:videoId>3sRaP3agFU4</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>How to Get a PhD in Computer Science, and My Dissertation - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=3sRaP3agFU4"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>How to Get a PhD in Computer Science, and My Dissertation - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/3sRaP3agFU4?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/3sRaP3agFU4/hqdefault.jpg" width="480" height="360"/>
<media:description>Here I go over some of the basic aspects and procedures when getting a Ph.D. (doctoral degree) and going through my dissertation at a high level. The purpose of a Ph.D. is to get an academic job of some kind, and a dissertation is a culminating work in a particular subject, usually through some set of research and/or articles that are published in a peer-reviewed journal or conference. 

Getting a Ph.D. usually involves (1) a comprehensive examination, (2) prospectus, and (3) a dissertation (sometimes there is coursework and/or teaching assistant work too). The comprehensive exam is about understanding a graduate student's knowledge of the particular subject you're in, usually through a written and an oral component in front of a committee. The prospectus is an outline of the research topic, what things have been done for the research, and what the timeline for completing them is. A dissertation is a long document (usually over 100 pages) that contains an introduction to the subject, and all of the research done during the Ph.D. 

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Youtube Live Streaming (Sundays) - subscribe for when these occur.

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Micah Wood
Silver Supporters: Timmy Gy
Supporters: (none)

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:IBa__30xQQk</id>
<yt:videoId>IBa__30xQQk</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Easy Theory Mobile App Development #1</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=IBa__30xQQk"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Easy Theory Mobile App Development #1</media:title>
<media:content url="https://www.youtube.com/v/IBa__30xQQk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/IBa__30xQQk/hqdefault.jpg" width="480" height="360"/>
<media:description>#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught many courses at several different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:A11hypnoPM0</id>
<yt:videoId>A11hypnoPM0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>My Responses to Comments for my Video on Hacker News - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=A11hypnoPM0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>My Responses to Comments for my Video on Hacker News - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/A11hypnoPM0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/A11hypnoPM0/hqdefault.jpg" width="480" height="360"/>
<media:description>Here I give my off-the-cuff responses to comments on the video that made my channel a lot more popular (with 1k subs and 20k views). The video was the livestream I did solving all GATE exam questions (over 240 questions) in 4 hours, and providing an explanation for a lot of the questions.

Hacker News Post with comments: https://news.ycombinator.com/item?id=23759673
My Video: https://www.youtube.com/watch?v=g_ZdcHSFGv0

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at two different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:VssLdh6YhXI</id>
<yt:videoId>VssLdh6YhXI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #48: Regular Expressions Examples - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=VssLdh6YhXI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #48: Regular Expressions Examples - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/VssLdh6YhXI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/VssLdh6YhXI/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do some examples of regular expressions (regexes) - the main video is here: https://youtu.be/7phPFEMcfEs

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Show that any finite language can be described by a regex.
2. What other interesting regular expressions can you find?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at two different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:7phPFEMcfEs</id>
<yt:videoId>7phPFEMcfEs</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #47: Regular Expressions (Regexes) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=7phPFEMcfEs"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #47: Regular Expressions (Regexes) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/7phPFEMcfEs?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/7phPFEMcfEs/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at and define regular expressions, which allow us to describe, formally, what a language is. They are defined using three "base" cases (empty string, empty set, and a single character), and three "inductive" cases (union, concatenation, and star). 

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. What other operators can be included that can be achieved from union, concatenation, and star?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at two different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:ovsj9XE7oOQ</id>
<yt:videoId>ovsj9XE7oOQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #44: Regular Languages Closed Under "Avoids" Example (Sipser 1.70)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=ovsj9XE7oOQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #44: Regular Languages Closed Under "Avoids" Example (Sipser 1.70)</media:title>
<media:content url="https://www.youtube.com/v/ovsj9XE7oOQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/ovsj9XE7oOQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give an example of the fact that regular languages are closed under "avoids". The main video proving this is here: https://www.youtube.com/watch?v=y86jpV5tn_0

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Are there other interesting examples?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at two different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:y86jpV5tn_0</id>
<yt:videoId>y86jpV5tn_0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #43: Regular Languages Closed Under "Avoids" (Sipser 1.70 Solution)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=y86jpV5tn_0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #43: Regular Languages Closed Under "Avoids" (Sipser 1.70 Solution)</media:title>
<media:content url="https://www.youtube.com/v/y86jpV5tn_0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/y86jpV5tn_0/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that regular languages are closed under the "avoids" operation (Sipser 1.70 solution). This operation is all the strings in A that don't have any substring in B. This isn't the same as all the strings in A not in B. The idea is to build up what the definition of "avoids" means, by first considering all strings that *do* have some substring in B, and then take those strings away from A. 

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. How about subsequence avoidance?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at two different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:DMwpvOiz5pA</id>
<yt:videoId>DMwpvOiz5pA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #42: Regular Languages Closed Under Division (2 Examples!) (Sipser 1.45)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=DMwpvOiz5pA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #42: Regular Languages Closed Under Division (2 Examples!) (Sipser 1.45)</media:title>
<media:content url="https://www.youtube.com/v/DMwpvOiz5pA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/DMwpvOiz5pA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give two examples of closure under division for regular languages. The main video is here: https://youtu.be/mtURMW_VSUA

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Is there an example where A, B are both not empty, but A/B is empty?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at two different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:fVTLmyx6xkQ</id>
<yt:videoId>fVTLmyx6xkQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>100 Videos! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=fVTLmyx6xkQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>100 Videos! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/fVTLmyx6xkQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/fVTLmyx6xkQ/hqdefault.jpg" width="480" height="360"/>
<media:description>#easytheory

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:mtURMW_VSUA</id>
<yt:videoId>mtURMW_VSUA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #41: Regular Languages Closed Under Division (Sipser 1.45 Solution)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=mtURMW_VSUA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #41: Regular Languages Closed Under Division (Sipser 1.45 Solution)</media:title>
<media:content url="https://www.youtube.com/v/mtURMW_VSUA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/mtURMW_VSUA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that if A and B are regular, then A/B is regular, where this is the set of all strings w such that wx is in A for some x in B. We show that this is regular by making a DFA for it by changing the final states of A. The new final states are going to be the ones where reading ANY string from B will result in an ORIGINAL final state of A. This is not a "constructive" method for a DFA, but this shows that the DFA exists, which is all that is needed.

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Can it be possible that A/B is equal to B/A (without using trivial examples of A, B)?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at two different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:tVF1CQnGPEY</id>
<yt:videoId>tVF1CQnGPEY</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #40: DFA Minimization Example - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=tVF1CQnGPEY"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #40: DFA Minimization Example - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/tVF1CQnGPEY?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/tVF1CQnGPEY/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give two examples on how to minimize a DFA. The main video is here: https://www.youtube.com/watch?v=685Wn0xFCrs. The idea is to "group" states together based on "equivalence" and then to refine the groups until no longer possible. 

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. For each positive integer n, find an example DFA where the minimum number of states is n.

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at two different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:685Wn0xFCrs</id>
<yt:videoId>685Wn0xFCrs</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #39: DFA Minimization - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=685Wn0xFCrs"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #39: DFA Minimization - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/685Wn0xFCrs?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/685Wn0xFCrs/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show how to minimize a DFA. The idea is to consider all "groups" of states that can be "equivalent" to each other in terms of accepting a string (e.g., a state that is non-final and a final state cannot be equivalent, because one accepts a string and the other doesn't). Then, we further refine the groups until it is not possible to refine them any more (which must happen at some point because at worst, every state is in its own group). Then, the "minimized" DFA is just one state for each group, and transitions between the groups as defined in the given DFA (since each state within a group is equivalent to each other one).

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Would this process work for NFAs?
2. Can you give an explicit runtime on the algorithm?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at two different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:3IJrvxJL-io</id>
<yt:videoId>3IJrvxJL-io</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #38: Regular Languages Closed Under Suffix Example - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=3IJrvxJL-io"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #38: Regular Languages Closed Under Suffix Example - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/3IJrvxJL-io?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/3IJrvxJL-io/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do an example on showing that regular languages are closed under suffix. Main video is here: https://www.youtube.com/watch?v=UQRsGun4l7Y

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. 

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at two different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:UQRsGun4l7Y</id>
<yt:videoId>UQRsGun4l7Y</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #37: Regular Languages Closed Under Suffix - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=UQRsGun4l7Y"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #37: Regular Languages Closed Under Suffix - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/UQRsGun4l7Y?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/UQRsGun4l7Y/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that regular languages are closed under suffix. The main idea is to understand that a suffix is the end of a string, and so to recognize all suffixes, we need to "jump past" the prefix (the beginning) of the string. We achieve this simply with nondeterminism, by making an NFA for the suffix language.

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. How many states will the corresponding DFA have, if the NFA has n states?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at two different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:q9VSXeal_vM</id>
<yt:videoId>q9VSXeal_vM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>We are back!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=q9VSXeal_vM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>We are back!</media:title>
<media:content url="https://www.youtube.com/v/q9VSXeal_vM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/q9VSXeal_vM/hqdefault.jpg" width="480" height="360"/>
<media:description>#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at two different universities, including several sections of undergraduate and graduate theory-level classes.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:_GXscdcIUJE</id>
<yt:videoId>_GXscdcIUJE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Updates to Easy Theory, and What's Coming</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=_GXscdcIUJE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Updates to Easy Theory, and What's Coming</media:title>
<media:content url="https://www.youtube.com/v/_GXscdcIUJE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/_GXscdcIUJE/hqdefault.jpg" width="480" height="360"/>
<media:description>Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Construct an NFA for the example homomorphism given in the video applied to a "starter" DFA.
2. Can it be possible for a finite language L to have h(L) be infinite?
3. Can it be possible for an infinite language L to have h(L) be finite?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:U_cdiPfykTI</id>
<yt:videoId>U_cdiPfykTI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #36: Regular Languages Closed Under Homomorphism - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=U_cdiPfykTI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #36: Regular Languages Closed Under Homomorphism - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/U_cdiPfykTI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/U_cdiPfykTI/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that the regular languages are closed under homomorphism, which is a function from Sigma* to itself that has a nice "splitting" property. We use this property in the proof by constructing an NFA for the desired "homomorphism" language, by breaking up every transition into many smaller transitions.

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Construct an NFA for the example homomorphism given in the video applied to a "starter" DFA.
2. Can it be possible for a finite language L to have h(L) be infinite?
3. Can it be possible for an infinite language L to have h(L) be finite?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:az0AUQpI5_0</id>
<yt:videoId>az0AUQpI5_0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #16 with Easy Theory - Prove this language is not Context-Free</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=az0AUQpI5_0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #16 with Easy Theory - Prove this language is not Context-Free</media:title>
<media:content url="https://www.youtube.com/v/az0AUQpI5_0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/az0AUQpI5_0/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:7OzQ8ItYGSw</id>
<yt:videoId>7OzQ8ItYGSw</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #35: Regular Languages Closed Under Reversal - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=7OzQ8ItYGSw"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #35: Regular Languages Closed Under Reversal - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/7OzQ8ItYGSw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/7OzQ8ItYGSw/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that regular languages are closed under reversal, and give some tips on why the "usual" proof is not quite right. The main idea is to take a DFA for the language, and reverse all of its transitions. The problem is that the resulting machine may not necessarily be a DFA or even an NFA. But by observing what the resulting language should be (the reverse of all the strings), we can make some adjustments to it to make it work, which we cover in the video.

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. How large will the "reverse" DFA be in relation to the original one? (after converting from an NFA to DFA)
2. What if we ask all strings such that some substring of it is reversed?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:2bPMta_92tI</id>
<yt:videoId>2bPMta_92tI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #34: Regular Languages Closed Under Subsequences (60 FPS!) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=2bPMta_92tI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #34: Regular Languages Closed Under Subsequences (60 FPS!) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/2bPMta_92tI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/2bPMta_92tI/hqdefault.jpg" width="480" height="360"/>
<media:description>(Easy Theory is in 60 FPS now!) Here we look at the problem of showing that regular languages are closed under subsequences (i.e., a substring but doesn't have to be contiguous). The idea is to "eliminate" transitions in the initial DFA by introducing epsilon transitions for every existing transition. We also give a concrete example of this.

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. What about "supersequences"? (i.e., all strings that include some string w in L as a subsequence)
2. What about substrings? 

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:bbMku8ZAoBk</id>
<yt:videoId>bbMku8ZAoBk</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #32: Complementing NFAs Ruins EVERYTHING! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=bbMku8ZAoBk"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #32: Complementing NFAs Ruins EVERYTHING! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/bbMku8ZAoBk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/bbMku8ZAoBk/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the question of complementing an NFA (i.e., switch all final and non-final states), and show that anything can happen! Either the resulting NFA accepts more strings, the right number of strings, or fewer strings than what is intended. Further, we give examples of all three cases. 

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Is there a general construction for n states that exhibits these three behaviors?
2. Is there an NFA (that is not already a DFA) that when complemented gives the right strings?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Nyzwq4CA3KE</id>
<yt:videoId>Nyzwq4CA3KE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #31: Minimal NFAs are NOT Unique! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Nyzwq4CA3KE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #31: Minimal NFAs are NOT Unique! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Nyzwq4CA3KE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Nyzwq4CA3KE/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at a cool problem sent by user @TMD on our Discord server, which shows that minimal NFAs are not unique! We show this by constructing the equivalent DFA for both of them, and that they produce the same DFA, meaning they have the same language. But they are not the same NFA, whereas minimal DFAs are always the same.

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Can you prove minimal DFAs are always the "same"?
2. Can you find a smaller set of NFAs that are different and have the same language?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:oCRbwLXvNjI</id>
<yt:videoId>oCRbwLXvNjI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #30: NFA to DFA Examples (Powerset Construction) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=oCRbwLXvNjI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #30: NFA to DFA Examples (Powerset Construction) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/oCRbwLXvNjI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/oCRbwLXvNjI/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do two off-the-cuff examples of the NFA to DFA (Powerset) construction. The idea is to take the epsilon closure of the start state, and then repeatedly find "where to go" on each of the input symbols, always taking into account epsilon closure of the resulting states. Then, the final states are the ones that include an originally final state in the NFA. The second example is a slight modification of the first, and shows how small changes in the NFA can result in dramatically many more states. 

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. How large can the NFA be compared to the DFA?
2. What happened to all of the other subsets of the NFA's states that weren't considered here?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:PPiebTISJBk</id>
<yt:videoId>PPiebTISJBk</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #27: NFA to DFA Conversion (Powerset Construction) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=PPiebTISJBk"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #27: NFA to DFA Conversion (Powerset Construction) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/PPiebTISJBk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/PPiebTISJBk/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that NFAs and DFAs are equivalent, with the powerset construction. The idea is that the DFA will "simulate" all possible choices that the NFA could make. We repeatedly take note of what states the NFA could be in at a given point, and "merge" them all into a single state. We repeat until no states have "unused" transitions in the DFA. 

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Can you find an example of an NFA to DFA conversion where all 2^n states for the DFA will be made, no matter what?
2. Is the DFA produced from the conversion always of minimum size?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Ul9QTb7wUek</id>
<yt:videoId>Ul9QTb7wUek</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #26: ε-closure: what is it? (epsilon closure) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Ul9QTb7wUek"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #26: ε-closure: what is it? (epsilon closure) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Ul9QTb7wUek?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Ul9QTb7wUek/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at ε-closure (or epsilon closure), which is important in the NFA to DFA conversion process. The basic idea is to consider a set of states, and every set of states "reachable" from that set (including the original) using only ε-transitions. We give several examples as well.

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Can the ε-closure ever be empty?
2. What is the ε-closure of a state in a DFA?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:oHX2hZInXc0</id>
<yt:videoId>oHX2hZInXc0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Strong Rice's Theorem - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=oHX2hZInXc0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Strong Rice's Theorem - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/oHX2hZInXc0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/oHX2hZInXc0/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we prove a "stronger" version of Rice's theorem, which involves nontrivial properties of Turing Machine languages. The basic idea is to add an additional constraint on what the property can be. Then through this, we can create a reduction from the complement of A_TM to the property, and the former is not recognizable, so the property itself cannot be recognizable. This is stronger because the original Rice's theorem only shows undecidability, but does not necessarily show not recognizable.

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: Timmy Gy
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. What other constraints on P can you use to show not recognizable?
2. What sufficient criteria can show that P *and* complement of P are not recognizable?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:ZyMVaJYyehY</id>
<yt:videoId>ZyMVaJYyehY</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #25: Product Construction for NFAs!? (Without a DFA at all!) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=ZyMVaJYyehY"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #25: Product Construction for NFAs!? (Without a DFA at all!) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/ZyMVaJYyehY?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/ZyMVaJYyehY/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show how to perform a "product" type construction on two NFAs. The basic idea is to follow the similar proof with the construction with two DFAs, but modify it for two NFAs by considering multiple transitions from the same state, and epsilon transitions. 

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: (none)
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Does this idea also work for union of two NFAs?
2. What about complement of an NFA?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.comt

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:eBtyoFUkLis</id>
<yt:videoId>eBtyoFUkLis</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #15 with Easy Theory - Pumping Lemma for CFLs, CFG to PDA, Many TM Questions!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=eBtyoFUkLis"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #15 with Easy Theory - Pumping Lemma for CFLs, CFG to PDA, Many TM Questions!</media:title>
<media:content url="https://www.youtube.com/v/eBtyoFUkLis?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/eBtyoFUkLis/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:9Gc7DWcNVBs</id>
<yt:videoId>9Gc7DWcNVBs</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Patreon Livestream #1 - Is it Lonely in Here?</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=9Gc7DWcNVBs"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Patreon Livestream #1 - Is it Lonely in Here?</media:title>
<media:content url="https://www.youtube.com/v/9Gc7DWcNVBs?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/9Gc7DWcNVBs/hqdefault.jpg" width="480" height="360"/>
<media:description>Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: (none)
Supporters: Yash Singhal       

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:DtdtlPh_QzU</id>
<yt:videoId>DtdtlPh_QzU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #23: How many computations in an NFA? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=DtdtlPh_QzU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #23: How many computations in an NFA? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/DtdtlPh_QzU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/DtdtlPh_QzU/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the question of how many computations there are in a nondeterministic finite automaton (NFA). It turns out to be a very surprising answer, because NFAs allow for multiple transitions, epsilon transitions, and even missing transitions, which DFAs don't allow for any of them. We also then show that the same idea for closure under complement for DFAs does not work for NFAs.

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: (none)
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Is there an NFA that isn't a DFA for which closure under complement DOES work?
2. How big can a "complement" NFA be compared to the original?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:P5iWwYtwlwg</id>
<yt:videoId>P5iWwYtwlwg</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #22: What is an NFA, and why do we care? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=P5iWwYtwlwg"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #22: What is an NFA, and why do we care? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/P5iWwYtwlwg?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/P5iWwYtwlwg/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we ponder the question about what is "necessary" for a state-based machine to recognize the concatenation of two regular languages (or the star of one). We realize that we only need "epsilon" transitions to be able to "instantaneously" jump from one state to another, as well as allow for "nondeterminism". We call these NFAs (nondeterministic finite automata), and we show that we can achieve concatenation and star really easily with them (and even union!). The problem is that they are not the same thing as DFAs, and in a future lecture we will show equivalence.

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: (none)
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Can you make an NFA for all strings that contain 011 as a substring? How many states are needed?
2. How small can an NFA be comparatively to a DFA for the same language? (Try working out small examples).

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:a_koKXDCHUw</id>
<yt:videoId>a_koKXDCHUw</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #21: Are there DFAs for Concatenation and Star? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=a_koKXDCHUw"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #21: Are there DFAs for Concatenation and Star? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/a_koKXDCHUw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/a_koKXDCHUw/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the question of whether there are DFAs for concatenation or star. We saw that concatenation and star are two regular operations, so it's natural to ask if A, B are regular, then AB is regular also (or A* also regular)? The question turns out to be difficult to answer, because one would need to magically "guess" where the split of the string is, as well as "jumping" to the other DFA to read the rest of the string without consuming a character.

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT, 2 hours):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard, Yonatan H.
Silver Supporters: (none)
Supporters: Yash Singhal       

▶ADDITIONAL QUESTIONS◀
1. Can you find DFAs for concatenation and star?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:BZDy_wTSeJI</id>
<yt:videoId>BZDy_wTSeJI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #18: What are the Regular Operations? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=BZDy_wTSeJI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #18: What are the Regular Operations? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/BZDy_wTSeJI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/BZDy_wTSeJI/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we define the "regular operations": union, concatenation, and star. Union is just putting together the strings in two given languages. Concatenation takes one string from each language and "glues" them together. And star involves any number of concatenations from a given language with itself (think of star as concatenation on steroids!).

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: (none)
Supporters: Yash Singhal    

▶ADDITIONAL QUESTIONS◀
1. Is the star of any language always infinite? If not, when is it not?
2. Can a finite number of unions and concatenations (no star) result in an infinite language?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:EMLuNJw3yuY</id>
<yt:videoId>EMLuNJw3yuY</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #14: Regular Languages Closed Under Union/Intersection (Product Construction)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=EMLuNJw3yuY"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #14: Regular Languages Closed Under Union/Intersection (Product Construction)</media:title>
<media:content url="https://www.youtube.com/v/EMLuNJw3yuY?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/EMLuNJw3yuY/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show how to achieve closure under union for regular languages, with the so-called "product construction". The idea is to "simulate" two given DFAs at the same time, because the input can only be read once. The resulting DFA has pairs of states for each of the original states in both DFAs, and transitions between them based on how the original DFAs had transitions.

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. How can you show regular languages are closed under intersection?
2. Find two DFAs whose "product construction" DFA has the smallest number of states possible for that language, and another two where the resulting DFA does not.
3. How many final states are in the union-ed DFA?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:eQKhPT8tEgo</id>
<yt:videoId>eQKhPT8tEgo</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #14 with Easy Theory - Context-Free Grammars, and some GATE problems!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=eQKhPT8tEgo"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #14 with Easy Theory - Context-Free Grammars, and some GATE problems!</media:title>
<media:content url="https://www.youtube.com/v/eQKhPT8tEgo?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/eQKhPT8tEgo/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:9_yhHI-IDSk</id>
<yt:videoId>9_yhHI-IDSk</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Ten Thousand Views! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=9_yhHI-IDSk"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Ten Thousand Views! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/9_yhHI-IDSk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/9_yhHI-IDSk/hqdefault.jpg" width="480" height="360"/>
<media:description>Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

Ultimate Supporters: (none)
Diamond Supporters: (none)
Platinum Supporters: (none)
Gold Supporters: Anonymous (x1), Micah Wood, Ben Pritchard
Silver Supporters: (none)
Supporters: Yash Singhal    

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Zq_aakGIIiM</id>
<yt:videoId>Zq_aakGIIiM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #13: Regular Languages Closed Under Complement - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Zq_aakGIIiM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #13: Regular Languages Closed Under Complement - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Zq_aakGIIiM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Zq_aakGIIiM/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that regular languages are closed under complement, in that if L is a regular language, then L' (the set of all strings not in L) is also regular. We prove this by considering a DFA for L, then trying to construct a DFA for L' by swapping the final and non-final states. 

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Are finite languages closed under complement?
2. What else about a DFA guarantees that swapping the final and non-final states works? (Hint: number of computations.)

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:xTIddipVd2M</id>
<yt:videoId>xTIddipVd2M</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #12: What is a Regular Language? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=xTIddipVd2M"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #12: What is a Regular Language? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/xTIddipVd2M?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/xTIddipVd2M/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we define what a regular language is, in that it corresponds to a DFA (deterministic finite automaton). All that is needed is for the DFA to exist, and not necessarily to give the DFA precisely. We also give some examples of regular languages that we have seen before.

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Give an infinite regular language that is not Sigma*.
2. What can we say about L if L is a finite language?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:D12PEIQhH1A</id>
<yt:videoId>D12PEIQhH1A</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #6: What are the languages of DFAs? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=D12PEIQhH1A"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #6: What are the languages of DFAs? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/D12PEIQhH1A?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/D12PEIQhH1A/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we define the language of a DFA, which is the set of all strings that it accepts. Then we look at an example DFA, and try to discern what language it has. We produce some example strings that it accepts, and then see the pattern that it accepts exactly the strings that have a length a multiple of 3 plus 1. 

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Design a DFA with language of all strings w in {0, 1}* that start and end with a 0, or start and end with a 1, or is epsilon. (Super hard: what if w was in {0, 1, 2}*?)
2. Design a DFA with language of all strings in {0, 1}* that contain 111 as a substring.

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:cOITFNI53ps</id>
<yt:videoId>cOITFNI53ps</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #5: WTF is a DFA Computation? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=cOITFNI53ps"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #5: WTF is a DFA Computation? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/cOITFNI53ps?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/cOITFNI53ps/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we go over the concept of a DFA computation, which can be a bit daunting. The idea is to record the states of the DFA one at a time as the string is being read. Instead of thinking about a set of states visited (which cannot distinguish what the string is), the sequence of states can actually tell us quite a bit about what the DFA did on the input string. I give some examples of computations on a given DFA, as well as some definitions that relate to strings.

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. If the DFA has n states, what if the input string has length n?
2. Can you determine a necessary and sufficient condition for a DFA to accept an infinite number of strings?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:g_ZdcHSFGv0</id>
<yt:videoId>g_ZdcHSFGv0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Solutions for EVERY GATE Theory of Computation Question!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=g_ZdcHSFGv0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Solutions for EVERY GATE Theory of Computation Question!</media:title>
<media:content url="https://www.youtube.com/v/g_ZdcHSFGv0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/g_ZdcHSFGv0/hqdefault.jpg" width="480" height="360"/>
<media:description>In which we solve EVERY exam problem offered from GATE theory exams until 2020. There are 247 questions in this list, and we tackle (most of) them, and try not to lose our minds! Thank you all for supporting this channel - hopefully this is a good Memorial Day's viewing.

#easytheory #nfa #dfa #gate #gateconcept #theoryofcomputing #turingmachine #nfatoregex #cfg #pda #undecidable #ricestheorem

Questions came from: https://pyq.ravindrababuravula.com/subject/?cs=Theory-of-Computation

00:00:00 GATE 2019
00:07:12 GATE 2020 
00:14:36 GATE 2018
00:22:29 GATE 2017 (Set 1)
00:33:37 GATE 2017 (Set 2)
00:40:55 GATE 2016 (Set 1)
00:49:18 GATE 2016 (Set 2)
00:54:51 GATE 2015 (Set 1)
01:03:12 GATE 2015 (Set 2)
01:08:30 GATE 2015 (Set 3)
01:11:30 GATE 2014 (Set 1)
01:12:35 GATE 2014 (Set 2)
01:19:19 GATE 2014 (Set 3)
01:24:52 GATE 2013 
01:28:16 GATE 2012
01:31:21 GATE 2011 
01:33:43 GATE 2010
01:38:43 GATE 2009
01:44:18 GATE 2008
01:59:17 GATE 2008 (IT)
02:08:25  GATE 2007
02:11:20 GATE 2007 (IT)
02:22:19 GATE 2006
02:28:33 GATE 2006 (IT)
02:38:00 GATE 2005
02:42:30 GATE 2005 (IT)
02:55:50 GATE 2004
02:57:58 GATE 2004 (IT)
03:02:57 GATE 2003
03:11:42 GATE 2002
03:14:32 GATE 2000
03:17:39 GATE 1999
03:20:42 GATE 1998
03:27:31 GATE 1997
03:29:34 GATE 1996
03:35:00 GATE 1995
03:38:13 GATE 1994
03:39:40 GATE 1992
03:42:39 GATE 2001
03:47:22 GATE 1991

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:lTIQnD_gNS4</id>
<yt:videoId>lTIQnD_gNS4</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #13 with Easy Theory - Induction, GATE questions, Restricted DFAs!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=lTIQnD_gNS4"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #13 with Easy Theory - Induction, GATE questions, Restricted DFAs!</media:title>
<media:content url="https://www.youtube.com/v/lTIQnD_gNS4?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/lTIQnD_gNS4/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Z0e3NopJOZA</id>
<yt:videoId>Z0e3NopJOZA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #3: How to formally define a DFA - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Z0e3NopJOZA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #3: How to formally define a DFA - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Z0e3NopJOZA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Z0e3NopJOZA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we introduce what a DFA (deterministic finite automaton) is, and how to formally define one. We use the example from the last lecture and formally define that DFA.

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. How do you formally define the DFA in the thumbnail?
2. What is the fewest number of states a DFA can have?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:WWg_28jrmGw</id>
<yt:videoId>WWg_28jrmGw</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #2: Simple Machines, a How-To - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=WWg_28jrmGw"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #2: Simple Machines, a How-To - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/WWg_28jrmGw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/WWg_28jrmGw/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at "simple" machines, and create one that checks whether the length of the given input is even or not. We consider how many states are needed, as well as the start state, and how to connect the states together. We conclude with another example as "homework".

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What does the machine given at the end do?
2. Can you make the machine at the end "simpler" in terms of number of states?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:xilR6Ky6JhU</id>
<yt:videoId>xilR6Ky6JhU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #1: What is a Computer? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=xilR6Ky6JhU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #1: What is a Computer? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/xilR6Ky6JhU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/xilR6Ky6JhU/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we start a brand new series about the entire TOC class, about what a computer actually fundamentally is. It turns out we can simplify the model very greatly, by restricting the number of possible inputs, and the number of possible outputs. Then we look at how the machine operates, as it relates to the "states" during the course of computation.

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Give an informal argument as to why NOT fixing the internal memory changes the model.
2. If there are n memory cells in a computer, how many possible states are there?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:2eQiL2eAKU0</id>
<yt:videoId>2eQiL2eAKU0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>WHY is there an UNSOLVABLE problem? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=2eQiL2eAKU0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>WHY is there an UNSOLVABLE problem? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/2eQiL2eAKU0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/2eQiL2eAKU0/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at a proof that there is an "unsolvable" problem, in that there is no program to solve it. The idea is to think abstractly, and to consider a program as just one gigantic integer. Also, the number of "problems" is uncountably large, and therefore there must exist some unsolvable problem.

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Why are we justified in saying the "vast majority" of problems are unsolvable?
2. Can you find an explicit example of an unsolvable problem (informally)?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:oqat-spyHpM</id>
<yt:videoId>oqat-spyHpM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #49: Is this the Most Beautiful Exam Problem? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=oqat-spyHpM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #49: Is this the Most Beautiful Exam Problem? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/oqat-spyHpM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/oqat-spyHpM/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at what may be the most beautiful GATE exam problem: finding the minimum number of states for a DFA to recognize the regular expression (111 U 11111)*. We solve this in two ways: a "slow" way (involving converting the regex to an NFA, then the NFA to a DFA, then minimize the DFA), and a "fast" way involving looking at the question from a different angle. This may be one of the most beautiful problems I have ever seen, and it is so simple!

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What is the minimum number of states for (11 U 11111 U 1111111)* (2, 5, 7 ones)?
2. Can you determine the number of states for (1^n U 1^m)* in the general case? What about three strings or more?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:hMD0Ta5vYtQ</id>
<yt:videoId>hMD0Ta5vYtQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #12 with Easy Theory - Lots of HARD problemS!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=hMD0Ta5vYtQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #12 with Easy Theory - Lots of HARD problemS!</media:title>
<media:content url="https://www.youtube.com/v/hMD0Ta5vYtQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/hMD0Ta5vYtQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:2GNvJ2HXQPA</id>
<yt:videoId>2GNvJ2HXQPA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #11 with Easy Theory - Pumping Lemma for CFLs, DFAs, GATE Problem Solutions!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=2GNvJ2HXQPA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #11 with Easy Theory - Pumping Lemma for CFLs, DFAs, GATE Problem Solutions!</media:title>
<media:content url="https://www.youtube.com/v/2GNvJ2HXQPA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/2GNvJ2HXQPA/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Zbqq6G5CipU</id>
<yt:videoId>Zbqq6G5CipU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #7: How many DFAs accept ANY language L? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Zbqq6G5CipU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #7: How many DFAs accept ANY language L? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Zbqq6G5CipU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Zbqq6G5CipU/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the question of how many DFAs accept a given language L, which can be anything. This may seem like a silly question but it turns out to be interesting! If L is not regular, then clearly there is no DFA for L. But if L is regular, we can always add an "unreachable" state to an existing DFA for L as many times as we want. 

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. How many *minimal* DFAs are there for a regular language L?
2. Can you modify the construction so that you can always add a state that is always reachable?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:H-GYBjDpT6U</id>
<yt:videoId>H-GYBjDpT6U</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #19: The Star of ANY Unary Language is Regular?! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=H-GYBjDpT6U"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #19: The Star of ANY Unary Language is Regular?! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/H-GYBjDpT6U?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/H-GYBjDpT6U/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show the counterintuitive fact that for ANY unary language L, L* is regular! The idea exploits the fact that L is unary by looking at the lengths of the strings and not the strings themselves, and we can reduce this question to looking at the greatest common divisor of the lengths in the language (and reducing to a smaller case if necessary).

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Can you prove that if gcd(x,y) = 1, then any number at least (x-1)(y-1)-1 can be reached?
2. What about for binary languages?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:4tbCR10QGTI</id>
<yt:videoId>4tbCR10QGTI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>WHY is the Halting Problem Undecidable? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=4tbCR10QGTI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>WHY is the Halting Problem Undecidable? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/4tbCR10QGTI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/4tbCR10QGTI/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we concern ourselves with the Halting Problem (called HALT_TM) which asks whether a given Turing Machine halts (accepts or rejects) a given input w. We show that this problem is undecidable (i.e., no algorithm exists that runs in a finite amount of time for it). The idea is to suppose that a decider exists for HALT_TM, and then to create a decider for A_TM (which we know to be undecidable) based on that supposition, which gives us a contradiction.

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Can you prove that HALT_TM is undecidable without the knowledge of any other undecidable problem?
2. Can you prove it is undecidable using a different undecidable problem than A_TM?
3. Can you prove it undecidable in a completely different way?
4. Is HALT_TM recognizable?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:CxyUca_MuB8</id>
<yt:videoId>CxyUca_MuB8</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #24: NFA for Substrings of w! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=CxyUca_MuB8"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #24: NFA for Substrings of w! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/CxyUca_MuB8?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/CxyUca_MuB8/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show how to create an NFA for all substrings of a given string w. The idea is to first create an NFA for the language {w} (i.e., just w and nothing else). Then note that we can make all of the states final in this NFA, and then add epsilon-transitions for the substrings that can start "later" in the string. Note that this handles substrings, and not subsequences. 

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. How can you modify this NFA to make one for all subsequences of w?
2. Is this the smallest NFA in terms of the number of transitions?
3. Can a loop ever be added to an NFA like this?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:9Sl109TmSoU</id>
<yt:videoId>9Sl109TmSoU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #46: GATE 2019 Question 17 (Prefixes and Suffixes!) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=9Sl109TmSoU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #46: GATE 2019 Question 17 (Prefixes and Suffixes!) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/9Sl109TmSoU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/9Sl109TmSoU/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at a GATE 2019 problem for Exam Question Monday, about determining which of four languages is not regular. Two of the languages are Prefixes and Suffixes of a regular language, one is the concatenation of L and L^R, and the last is even-length palindromes over L. We show that regular languages are closed under prefix and suffix, as well as reversal, which yields that the last language is not regular. 

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Is {ww^R : w in {a,b}*} deterministic context free?
2. For what subsets L (not necessarily regular) is {ww^R : w in L} a regular language?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:LiVqq4Dc9Hc</id>
<yt:videoId>LiVqq4Dc9Hc</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #10 with Easy Theory - CFG to PDA, PDA to CFG!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=LiVqq4Dc9Hc"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #10 with Easy Theory - CFG to PDA, PDA to CFG!</media:title>
<media:content url="https://www.youtube.com/v/LiVqq4Dc9Hc?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/LiVqq4Dc9Hc/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:iuHbMH7tYr4</id>
<yt:videoId>iuHbMH7tYr4</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #11: DFA for Ternary Multiples of 5 (Pro-Tips included!) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=iuHbMH7tYr4"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #11: DFA for Ternary Multiples of 5 (Pro-Tips included!) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/iuHbMH7tYr4?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/iuHbMH7tYr4/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the language of strings that are ternary (base 3) multiples of 5. The idea is to make a DFA for all possibilities, which means the remainder with respect to 5. Then, all we do is relate each of the states to the others depending on whether we see a 0, 1, or 2. The pro-tip here is that one only needs to look at a single one of the transitions, and immediately the other transitions are determined. Another pro-tip is that this technique works in general, not just for base 3 and not just for multiples of 5!

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. How many transitions would a base-k multiple of n DFA have?
2. Is this the smallest DFA possible for this language?
3. Is this DFA unique?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:_0xgneWuTnk</id>
<yt:videoId>_0xgneWuTnk</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #69: Sparse Languages are Not Regular! [HARD Pumping Lemma!] - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=_0xgneWuTnk"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #69: Sparse Languages are Not Regular! [HARD Pumping Lemma!] - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/_0xgneWuTnk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/_0xgneWuTnk/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at a hard pumping lemma proof, in showing that the language of strings that are "sparse" (i.e., have 1s that are far apart) is not regular. There is a lot of subtlety in generating the string to pick, as well as how the decompositions are formed. However, the structure of the proof is very similar to every other pumping lemma proof. 

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. How would you adapt the proof for 1s being at least log_3 |w| characters apart?
2. Is this language context-free?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:neQxf_nYqCs</id>
<yt:videoId>neQxf_nYqCs</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #70: The p Factorial "Trick" (Advanced Pumping Lemma Technique!) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=neQxf_nYqCs"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #70: The p Factorial "Trick" (Advanced Pumping Lemma Technique!) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/neQxf_nYqCs?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/neQxf_nYqCs/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at something not talked about much on Youtube called the "p! trick", which is an advanced technique in using the pumping lemma to show that a language is not regular. The language is the strings from 0*1*2* such that the number of 0s + the number of 1s is even, and the number of 0s is odd, or the number of 1s is different than the number of 2s. 

The reason the p! trick works here is that every integer between 1 and p is divides p!, so we can design a string such that pumping it up "enough" (i.e., p! divided by such an integer) so that the number of 1s equals the number of 2s. 

Contribute:
Patreon: https://www.patreon.com/easytheory
Discord: https://discord.gg/SD4U3hs

Live Streaming (Saturdays, Sundays 2PM GMT):
Twitch: https://www.twitch.tv/easytheory
(Youtube also)
Mixer: https://mixer.com/easytheory

Social Media:
Facebook Page: https://www.facebook.com/easytheory/
Facebook group: https://www.facebook.com/groups/easytheory/
Twitter: https://twitter.com/EasyTheory

Merch:
Language Hierarchy Apparel: https://teespring.com/language-hierarchy?pid=2&amp;cid=2122
Pumping Lemma Apparel: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Can you find another language where the p! trick would be useful?
2. Can you prove that this language is not regular a different way?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:nZhAWPPDrF8</id>
<yt:videoId>nZhAWPPDrF8</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Decidable Language Closure Properties! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=nZhAWPPDrF8"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Decidable Language Closure Properties! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/nZhAWPPDrF8?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/nZhAWPPDrF8/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that decidable languages are closed under the five "main" operators: union, intersection, complement, concatenation, and star. The key is to assume deciders exist for the original language(s), and then to construct a decider for the desired language based off of the originals. Most of them are simple, but some require to examine all possible cases of the input being "split" into multiple pieces.

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Are decidable languages closed under homomorphism?
2. [Hard] Find an operation that decidable languages are NOT closed under. Bonus points if you can find one such that regular languages ARE closed under it (or to show one doesn't exist)! 

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:6SyRwpyQF6I</id>
<yt:videoId>6SyRwpyQF6I</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #77: A Double Conversion: Regular Grammar to NFA to Regex! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=6SyRwpyQF6I"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #77: A Double Conversion: Regular Grammar to NFA to Regex! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/6SyRwpyQF6I?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/6SyRwpyQF6I/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at a (rare) double conversion, which is converting from a regular grammar to an NFA (nondeterministic finite automaton) to a regular expression (regex). This comes from a 2017 exam question of mine. I walk through the steps in both of the conversions of how to perform them. 

For the regular grammar to NFA conversion, make a state for each of the variables of the NFA, as well as a single final state. Then, for each rule that produces a variable, go to that variable with the produced character (or on epsilon if none produced). If a rules makes epsilon or a character, go to the new final state on that character.

For the NFA to regex conversion, I walk through this process in this video: https://www.youtube.com/watch?v=UKYvP8aS7fM&amp;list=PLylTVsqZiRXMD7nqoHqEdCKdeGwGuO1KR&amp;index=6&amp;t=0s

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What is the maximum length of a regex that comes from the NFA to regex process? What about for this specific NFA?
2. Will the regex that comes out of the conversion look the same if we ripped out different states? When is it the case that they are identically the same?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:o8dxaJn4_XU</id>
<yt:videoId>o8dxaJn4_XU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #9 with Easy Theory - Homomorphisms, CNF, 2 Stacks = TMs, Nondeterminism, TM Variants!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=o8dxaJn4_XU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #9 with Easy Theory - Homomorphisms, CNF, 2 Stacks = TMs, Nondeterminism, TM Variants!</media:title>
<media:content url="https://www.youtube.com/v/o8dxaJn4_XU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/o8dxaJn4_XU/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:fGMvfYIWRDI</id>
<yt:videoId>fGMvfYIWRDI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #8 with Easy Theory - NFA Complement, Reductions, Homomorphisms!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=fGMvfYIWRDI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #8 with Easy Theory - NFA Complement, Reductions, Homomorphisms!</media:title>
<media:content url="https://www.youtube.com/v/fGMvfYIWRDI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/fGMvfYIWRDI/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:XBGgaXm94ew</id>
<yt:videoId>XBGgaXm94ew</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #17: The DFA Product Construction Ruins Everything! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=XBGgaXm94ew"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #17: The DFA Product Construction Ruins Everything! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/XBGgaXm94ew?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/XBGgaXm94ew/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the product construction for DFAs, and show that it "ruins" everything! Specifically, about minimality and reachability of the two original DFAs. If they both had no unreachable states, we don't guarantee that about the resulting DFA. And the same is true of minimality. 

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What has to be true about the original DFAs for the product DFA to also be minimal?
2. What about for reachability?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:NnYhVt-dB8U</id>
<yt:videoId>NnYhVt-dB8U</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #7 with Easy Theory - NFA to DFA, GNFA Conversion (NFA to Regular Expression)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=NnYhVt-dB8U"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #7 with Easy Theory - NFA to DFA, GNFA Conversion (NFA to Regular Expression)</media:title>
<media:content url="https://www.youtube.com/v/NnYhVt-dB8U?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/NnYhVt-dB8U/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:-X7X78X6C7c</id>
<yt:videoId>-X7X78X6C7c</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Sets, a Tutorial [Background Material] - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=-X7X78X6C7c"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Sets, a Tutorial [Background Material] - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/-X7X78X6C7c?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/-X7X78X6C7c/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do a different video than usual, by looking at the underlying object used in theory: sets. This is a background material video for anyone who wants to understand any other video on this channel, and to do theory at all. Sets are very simple objects, but they have incredibly powerful behavior when we look at more "complicated" sets. Here we look at some simple operations, such as union, intersection, set difference, powerset, and the Cartesian product of two small sets.

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Can you describe, using set operations, given three sets A, B, C, the set of all elements that are in at least two of the three sets?
2. How can one show that |A| = |B| if A, B are infinitely large sets? For example, if A was the integers, and B were the positive integers?
3. Is there a "set of all sets"?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:4MSbKcFLVRQ</id>
<yt:videoId>4MSbKcFLVRQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #6 with Easy Theory - Interesting Product Construction Problems!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=4MSbKcFLVRQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #6 with Easy Theory - Interesting Product Construction Problems!</media:title>
<media:content url="https://www.youtube.com/v/4MSbKcFLVRQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/4MSbKcFLVRQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:e4dUJ8NLjeA</id>
<yt:videoId>e4dUJ8NLjeA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #62: WHY do we have the three Pumping Lemma Conditions? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=e4dUJ8NLjeA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #62: WHY do we have the three Pumping Lemma Conditions? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/e4dUJ8NLjeA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/e4dUJ8NLjeA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the three conditions for the pumping lemma for regular languages, and discuss whether they are necessary, and where they come from. The surprising answer is that only two of the conditions are actually necessary! All three come from the proof of the pumping lemma, and we can deduce all of them easily from the fact that the given language L is regular (and so it has a DFA).

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What about the three conditions for the pumping lemma for context-free languages?
2. Can you give a formal proof of where we only have the two required conditions?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:rHmynKxk_aQ</id>
<yt:videoId>rHmynKxk_aQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #5 with Easy Theory - Proof of NFA = DFA, DFA Construction</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=rHmynKxk_aQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #5 with Easy Theory - Proof of NFA = DFA, DFA Construction</media:title>
<media:content url="https://www.youtube.com/v/rHmynKxk_aQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/rHmynKxk_aQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:DT0JvmVLlw4</id>
<yt:videoId>DT0JvmVLlw4</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Proof of Kruskal's Minimum Spanning Tree Algorithm - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=DT0JvmVLlw4"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Proof of Kruskal's Minimum Spanning Tree Algorithm - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/DT0JvmVLlw4?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/DT0JvmVLlw4/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we do a different video than usual, about algorithms! We show that Kruskal's Minimum Spanning Tree Algorithm is correct. (A tree is a graph without cycles, and spanning means every vertex is included. Minimum means of total minimum weight.) The idea is to think of each vertex as an "island", and that we are always maintaining islands (via merging), and islands always contain a tree. 

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What if we select edges from maximum weight going downwards? What is the resulting tree?
2. What is the run-time of this algorithm?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:h07oJjP40gc</id>
<yt:videoId>h07oJjP40gc</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #4 with Easy Theory - CFGs with Compilers, More Exam Questions!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=h07oJjP40gc"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #4 with Easy Theory - CFGs with Compilers, More Exam Questions!</media:title>
<media:content url="https://www.youtube.com/v/h07oJjP40gc?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/h07oJjP40gc/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:6EaQZeWJ_z0</id>
<yt:videoId>6EaQZeWJ_z0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #67: DFAs cannot count votes, even for almost-draws! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=6EaQZeWJ_z0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #67: DFAs cannot count votes, even for almost-draws! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/6EaQZeWJ_z0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/6EaQZeWJ_z0/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the language of strings that are almost-draws (i.e., the number of occurrences for characters can only differ by at most 1). We show that this language is not regular, in that there is no DFA for it. The trick is to use the pumping lemma, and to find a string that a hypothetical DFA must accept, but is nonetheless not an almost-draw. 

Hopefully we won't be using a DFA to count votes this election cycle! ;)

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Is this language context-free?
2. What if we had the alphabet be {a, b}, and not {a, b, c}?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:4cswnw6ECyk</id>
<yt:videoId>4cswnw6ECyk</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #3 with Easy Theory - First Donation! (And less important stuff like proofs)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=4cswnw6ECyk"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #3 with Easy Theory - First Donation! (And less important stuff like proofs)</media:title>
<media:content url="https://www.youtube.com/v/4cswnw6ECyk?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/4cswnw6ECyk/hqdefault.jpg" width="480" height="360"/>
<media:description>Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:MwJAHgq7e_Y</id>
<yt:videoId>MwJAHgq7e_Y</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #2 with Easy Theory - Exam Time!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=MwJAHgq7e_Y"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #2 with Easy Theory - Exam Time!</media:title>
<media:content url="https://www.youtube.com/v/MwJAHgq7e_Y?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/MwJAHgq7e_Y/hqdefault.jpg" width="480" height="360"/>
<media:description>[Full Exam Link]: https://pdfhost.io/v/o.lnKGkvt_exam_fullpdf.pdf

Powered by Restream https://restream.io/

Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a  C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:s55qA7gxCUg</id>
<yt:videoId>s55qA7gxCUg</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Office Hours #1 with Easy Theory - Chomsky Normal Form, Kruskal's Algorithm, PDA Acceptance</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=s55qA7gxCUg"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Office Hours #1 with Easy Theory - Chomsky Normal Form, Kruskal's Algorithm, PDA Acceptance</media:title>
<media:content url="https://www.youtube.com/v/s55qA7gxCUg?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/s55qA7gxCUg/hqdefault.jpg" width="480" height="360"/>
<media:description>Patreon: https://www.patreon.com/easytheory
Twitch: https://www.twitch.tv/easytheory
Mixer: https://mixer.com/easytheory
Discord: https://discord.gg/SD4U3hs
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory
Teespring: https://teespring.com/pumping-lemma-for-regular-lang

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:ezxi9uZEO_c</id>
<yt:videoId>ezxi9uZEO_c</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #68: Perfect Squares are Not Regular - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=ezxi9uZEO_c"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #68: Perfect Squares are Not Regular - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/ezxi9uZEO_c?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/ezxi9uZEO_c/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the language of perfect squares, and show that they are not regular. This is a classic proof using the pumping lemma, and relies on the fact that one can achieve a string that is not a perfect square, which would contradict the fact that the language was regular. 

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What if we set i = 3 in the proof?
2. Are there any other values of i that would also work?
3. What about any integer c for the language {0^{n^c} : n at least 0}?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:R9C9YiMNrFE</id>
<yt:videoId>R9C9YiMNrFE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #8: How many DFAs with 3 states and Σ = {0} are possible? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=R9C9YiMNrFE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #8: How many DFAs with 3 states and Σ = {0} are possible? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/R9C9YiMNrFE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/R9C9YiMNrFE/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the question of how many DFAs with 3 states and unary alphabet (Σ = {0}) are possible. It turns out to be a somewhat surprising answer. We first calculate the number of possible DFAs, and then turn to the question of how many *different* regular languages are possible. Then we break this down into cases, depending on how many states are final and how many of those are reachable from the start state. We then can eliminate more cases by noting that DFAs that are just complements of each other (final states and non-final states flipped) only need to be considered once.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What about for four-state DFAs?
2. What about two-state DFAs but Σ = {0, 1}?
3. What about three-state NFAs with Σ = {0}?
4. Is there a general formula for the number of DFAs with n states and an alphabet of size k?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:P08mxzF9pjM</id>
<yt:videoId>P08mxzF9pjM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #101: GATE 2019 Question 41 (Which of these languages is NOT Context-Free?)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=P08mxzF9pjM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #101: GATE 2019 Question 41 (Which of these languages is NOT Context-Free?)</media:title>
<media:content url="https://www.youtube.com/v/P08mxzF9pjM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/P08mxzF9pjM/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at a question from the GATE 2019 exam, about which of the four given languages is a context-free language. Instead of just giving the answer, we prove why the answer is what it is. For three of the languages, we are able to create a context-free grammar for each, and for the fourth, we appeal to the pumping lemma for context-free languages to prove that it is not a context-free language.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Is there another way to prove that the language is not a CFL?
2. Are all of these languages decidable?
3. Which of these languages is regular?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:P_F0-kY_kKQ</id>
<yt:videoId>P_F0-kY_kKQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #100: Context-Free Language Closure Properties, made EASY - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=P_F0-kY_kKQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #100: Context-Free Language Closure Properties, made EASY - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/P_F0-kY_kKQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/P_F0-kY_kKQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the five main closure properties--Union, Concatenation, Star, Intersection, and Complement--and show whether they are closed operations for context-free languages. We show that the first three are closed (just by making a simple additional rule to the original grammars), and the other two are not, by being able to produce {a^n b^n c^n : n at least 0}, which is not a CFL.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Can you find an explicit example of a CFL whose complement is not a CFL?
2. Are non-CFLs also closed under the same operations?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:HinUZ2f64bg</id>
<yt:videoId>HinUZ2f64bg</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #124: How to Count to Three, a Tutorial (THREE_DFA) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=HinUZ2f64bg"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #124: How to Count to Three, a Tutorial (THREE_DFA) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/HinUZ2f64bg?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/HinUZ2f64bg/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the language THREE_DFA, which is the set of all DFAs that accept at most three strings. This is related to the language INFINITE_DFA in that it helps us solve the problem. If the DFA does not accept infinitely many strings, then we can brute force through all possible remaining strings (at most the number of states - 1 in length), and then count the number of accepted strings. If you can solve this a different way, I would love to know about it!

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What is the time complexity of this method in solving THREE_DFA?
2. If instead we asked ONE_DFA (i.e., all DFAs accepting at most one string), is there any structure within the DFA we can assume or try to find?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:pKoJNAFo7NU</id>
<yt:videoId>pKoJNAFo7NU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #72: GATE 2020 Question 18 (Regular Languages Closed under Infinite Union?)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=pKoJNAFo7NU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #72: GATE 2020 Question 18 (Regular Languages Closed under Infinite Union?)</media:title>
<media:content url="https://www.youtube.com/v/pKoJNAFo7NU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/pKoJNAFo7NU/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at a GATE 2020 exam problem about two statements regarding regular languages, and asking which of them is true (or neither). The first asks if the union of two languages implies both of the original languages are regular, and the second concerns closure under infinite union for regular languages. Watch the video to figure out why the answer is false for both!

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What if instead of union for #1, we had L1 concatenated with L2?
2. Are regular languages always closed under *finite* unions?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:bOrsgRE8Juw</id>
<yt:videoId>bOrsgRE8Juw</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>A_LBA is Decidable...but Why? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=bOrsgRE8Juw"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>A_LBA is Decidable...but Why? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/bOrsgRE8Juw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/bOrsgRE8Juw/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the language A_LBA and show that it is decidable. The main idea is to be able to detect whether or not an LBA will run forever, which can be done by counting the possible configurations the machine can be in, and running it for one more step than that number. 

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What if we allow the machine to use twice the size of the input number of tape cells?
2. What if we restrict a Turing Machine instead to not modify any cell of the input?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:b2Gy6AArupo</id>
<yt:videoId>b2Gy6AArupo</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>GATE 2020 Question 36 (Which of these languages is undecidable?) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=b2Gy6AArupo"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>GATE 2020 Question 36 (Which of these languages is undecidable?) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/b2Gy6AArupo?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/b2Gy6AArupo/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at four languages: the set of TMs with empty language, the set of TMs that reach a certain state on a certain input in exactly 100 steps, the set of TMs with an undecidable language, and the set of TMs that accept at least 21 strings. We use Rice's theorem for three of the languages to show that they are undecidable. Not sure which ones? Watch the video to find out!

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What if the first language was all TMs with language not being the empty set?
2. What if the second language was all TMs that reach state q at *any* point in the computation on input w?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:YSgmw9t7OQs</id>
<yt:videoId>YSgmw9t7OQs</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Spotting Recognizable Languages [GATE Exam Problem] - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=YSgmw9t7OQs"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Spotting Recognizable Languages [GATE Exam Problem] - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/YSgmw9t7OQs?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/YSgmw9t7OQs/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we go over a GATE exam problem about a language of Turing Machines that accept some string of length 2020. We then classify this language as being undecidable but recognizable. The proof of undecidability is supposing a decider for it exists, then obtaining a decider for A_TM from that, which we know cannot exist. The proof of recognizable comes from "brute force" parallel simulation of all strings of length 2020, and accepting if any such string is accepted.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Could we have applied Rice's Theorem to this problem?
2. What can we say about the complement of L?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental theory of computer science. It sets out to define, mathematically, what exactly computation is, what is feasible to solve using a computer, and also what is not possible to solve using a computer. The main objective is to define a computer mathematically, without the reliance on real-world computers, hardware or software, or the plethora of programming languages we have in use today. The notion of a Turing machine serves this purpose and defines what we believe is the crux of all computable functions.

This channel is also about weaker forms of computation, concentrating on two classes: regular languages and context-free languages. These two models help understand what we can do with restricted means of computation, and offer a rich theory using which you can hone your mathematical skills in reasoning with simple machines and the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them are tractable, i.e. we can build efficient algorithms to reason with objects such as finite automata, context-free grammars and pushdown automata. For example, we can model a piece of hardware (a circuit) as a finite-state system and solve whether the circuit satisfies a property (like whether it performs addition of 16-bit registers correctly). We can model the syntax of a programming language using a grammar, and build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable. This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example, you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:HjBZUZEPepY</id>
<yt:videoId>HjBZUZEPepY</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #66: Don't Forget to Pump(ing Lemma) Twice! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=HjBZUZEPepY"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #66: Don't Forget to Pump(ing Lemma) Twice! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/HjBZUZEPepY?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/HjBZUZEPepY/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the language {0^m 1^n : m is less than sqrt(n) or n less than sqrt(m)}, and prove that it is not regular. We note that when we want to achieve a contradiction, the resulting string must not be in the language. But in this case, we have TWO conditions we have to satisfy. So therefore, we need to check both of them to be very sure that the resulting string is not in the language.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Is this language a CFL (context-free language)?
2. What if the condition instead were "AND"?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:kr7n_3LpWhc</id>
<yt:videoId>kr7n_3LpWhc</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>How to apply Rice's Theorem in 5 Minutes? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=kr7n_3LpWhc"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>How to apply Rice's Theorem in 5 Minutes? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/kr7n_3LpWhc?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/kr7n_3LpWhc/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the language of TMs that accept at most 3 strings, and show via Rice's Theorem that it is undecidable. The key is to point out that THREE_TM is a nontrivial property of Turing Machine languages. I show how to do this in general, and when one should use Rice's Theorem and when one should not.

Timestamps:
0:00 - Intro
0:54 - Step 0: can we apply Rice's Theorem?
1:30 - Step 1: Property of Turing Machine languages
2:45 - Step 2: The property is non-trivial
4:25 - Conclusion of proof

Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What about TMs accepting at most 3 strings and have at most 7 states?
2. What about TMs accepting at least 0 strings?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:-mw3Em5rS60</id>
<yt:videoId>-mw3Em5rS60</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #16: Number of Final States in Product Construction - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=-mw3Em5rS60"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #16: Number of Final States in Product Construction - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/-mw3Em5rS60?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/-mw3Em5rS60/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at a classic question: given two DFAs, where everything we know about them is the number of states and number of final states in each, can we figure out the number of final states in the product construction (for the union of their languages)? It turns out to be pretty interesting, in that we need to understand what the final states actually are in the resulting DFA. Then we count the states that we know are in F, but notice that we double count some of them, so we have to subtract them out.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What about for the intersection of their languages?
2. What about for the symmetric difference? (in exactly one of L(D1) and L(D2), not both).
3. What about for the NFA to DFA conversion?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Kwa8XF38WrY</id>
<yt:videoId>Kwa8XF38WrY</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #80: CFG for Palindromes over {0,1}, made EASY! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Kwa8XF38WrY"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #80: CFG for Palindromes over {0,1}, made EASY! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Kwa8XF38WrY?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Kwa8XF38WrY/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we make a simple context free grammar for palindromes over {0,1}, by breaking up the string into "base cases" and "inductive cases". We make a rule for the base cases, and then consider how to use the variable to "recurse" for the inductive cases.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What about strings of the form ww?
2. What about all even length palindromes?
3. What about strings that start with a 0 and end with a 1, and the "middle" part is a palindrome?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:CuYZIsBSguw</id>
<yt:videoId>CuYZIsBSguw</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #33: Regular Language Closure Properties, ALL Proofs Included! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=CuYZIsBSguw"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #33: Regular Language Closure Properties, ALL Proofs Included! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/CuYZIsBSguw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/CuYZIsBSguw/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we prove five closure properties of regular languages, namely union, intersection, complement, concatenation, and star. We utilize results such as NFAs = DFAs, and give proofs for *why* all of these properties are closed for regular languages.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What about for context-free languages?
2. What about symmetric difference? (Set of strings that are in one of the two languages but not both)
3. What about majority of three languages A, B, C? (i.e., A, B, C are all regular and I want all strings that are in at least two of A, B, C)

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:zM3bKd-9334</id>
<yt:videoId>zM3bKd-9334</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #81: {0^n 1^n 2^m 3^m} Union {0^n 1^m 2^m 3^n} Context-Free Grammar</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=zM3bKd-9334"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #81: {0^n 1^n 2^m 3^m} Union {0^n 1^m 2^m 3^n} Context-Free Grammar</media:title>
<media:content url="https://www.youtube.com/v/zM3bKd-9334?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/zM3bKd-9334/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that the union of two given context-free languages, {0^n 1^n 2^m 3^m} Union {0^n 1^m 2^m 3^n}, is also a context-free language. We give a context-free grammar for each of them, and derive a context-free grammar for their union.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Would this work for the intersection of the two languages?
2. What about {0^n 1^m 2^n 3^m}?
3. Is this the smallest CFG for this language?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:gPyBg6FN1pE</id>
<yt:videoId>gPyBg6FN1pE</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #20: All languages are regular?! Spot the Proof Error(s)! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=gPyBg6FN1pE"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #20: All languages are regular?! Spot the Proof Error(s)! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/gPyBg6FN1pE?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/gPyBg6FN1pE/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give a (faulty) proof that all languages are regular. We use the basic notions and concepts related to regular languages to give a "proof" of this fact. Can you spot the error(s)?

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Can you prove something about the resulting NFA/DFA if you were to construct this using the product construction directly? 

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:jIAEpYwJgbA</id>
<yt:videoId>jIAEpYwJgbA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>How do you prove Rice's Theorem in 12 minutes? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=jIAEpYwJgbA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>How do you prove Rice's Theorem in 12 minutes? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/jIAEpYwJgbA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/jIAEpYwJgbA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we prove Rice's Theorem in 12 minutes, which is the shortest proof I can find! The idea is to show that every nontrivial property of Turing Machine languages is undecidable. We show that if such a property were decidable, then we can decide A_TM, which is well known to be undecidable. The trick is to use the fact that the property is nontrivial to find a machine that is in the property, and another that is not, and to construct a new machine that behaves like one if and only if the input TM accepts w. 

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Does the property always have to be nontrivial?
2. Does the property always have to be a property of TM languages?
3. Are there examples of the property that are recognizable?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:iwuu6Ox88CI</id>
<yt:videoId>iwuu6Ox88CI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #121: Infinite DFAs (and showing it is decidable!) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=iwuu6Ox88CI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #121: Infinite DFAs (and showing it is decidable!) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/iwuu6Ox88CI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/iwuu6Ox88CI/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that the problem of checking whether a DFA's language is infinite is decidable. The idea is to appeal to the pumping lemma for regular languages, and then make a certain DFA with the property that its language is empty if and only if the original DFA's language was finite (or infinite). Then the question boils down to asking whether the constructed DFA's language is empty (which is decidable).

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Can we do a similar question with PDAs/CFGs?
2. What about with Turing Machines?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:ZImtQBMSW_Y</id>
<yt:videoId>ZImtQBMSW_Y</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #89: Context-Free Grammar to Pushdown Automaton (CFG to PDA Conversion)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=ZImtQBMSW_Y"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #89: Context-Free Grammar to Pushdown Automaton (CFG to PDA Conversion)</media:title>
<media:content url="https://www.youtube.com/v/ZImtQBMSW_Y?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/ZImtQBMSW_Y/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show, with an exam question, how to convert any CFG into a PDA easily. The idea is to build the 4 "base" states, and then self loops on the third state for each terminal. Initially push on a $, then the start variable, and pop the $ going to the 4th state. Then, add a series of transitions for every rule, popping the LHS variable, and then pushing on the RHS in reverse order.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What would the PDA look like if the CFG were in Chomsky Normal Form?
2. What if the grammar were a regular grammar?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:SvrCSZXESA8</id>
<yt:videoId>SvrCSZXESA8</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #123: How to check if a DFA satisfies a specification (SUB_DFA)!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=SvrCSZXESA8"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #123: How to check if a DFA satisfies a specification (SUB_DFA)!</media:title>
<media:content url="https://www.youtube.com/v/SvrCSZXESA8?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/SvrCSZXESA8/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that it is decidable to check if a DFA satisfies a specification, given by another DFA. We reduce the problem to determining if one DFA accepts a string that the other does not. Then, this is equivalent to applying the product construction and determining if that resulting DFA accepts anything. Then we run the decider for E_DFA on that DFA.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Would this work if the specification is a CFG or PDA?
2. Would this work if the given machine was a PDA, and the specification was a DFA?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:7sm0MGYgTSU</id>
<yt:videoId>7sm0MGYgTSU</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #122: Useless States in a DFA is Decidable! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=7sm0MGYgTSU"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #122: Useless States in a DFA is Decidable! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/7sm0MGYgTSU?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/7sm0MGYgTSU/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that deciding whether or not a DFA has useless states is decidable. A useless state is one that, when removing it, does not change the language of the machine. This is a useful problem because it allows one to ask whether or not the machine is minimized or not.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Can we ask whether or not there is a useless state in an NFA?
2. What about a PDA?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Ow-gfFkXPZw</id>
<yt:videoId>Ow-gfFkXPZw</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Pumping Lemma for Regular Languages PROOF IN FOUR MINUTES - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Ow-gfFkXPZw"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Pumping Lemma for Regular Languages PROOF IN FOUR MINUTES - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Ow-gfFkXPZw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Ow-gfFkXPZw/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give a very quick proof of the pumping lemma for regular languages. The question just asks about strings that are also accepted in a given DFA. We partition the string up into pieces (as long as the string was accepted and at least the number of states), and repeat the middle piece, yielding another accepted string. Then, we make observations about where the middle piece can be.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Is any one of the three conditions unnecessary? 
2. Does the initial string have to be accepted?
3. Does the initial string have to be at least the number of states in length?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Ms3zpTbqmBI</id>
<yt:videoId>Ms3zpTbqmBI</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #45: Strings that are not substrings but are subsequences...WHAT?!</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Ms3zpTbqmBI"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #45: Strings that are not substrings but are subsequences...WHAT?!</media:title>
<media:content url="https://www.youtube.com/v/Ms3zpTbqmBI?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Ms3zpTbqmBI/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the language of all strings within a regular language L that, given a finite language L', (1) no string in L contains a substring that is a string in L', and (2) for each string in L', it is a sub*sequence* of a string in L. The goal is to show the resulting language is regular. 

Yes, I know it sounds complicated, but the idea is very simple. We just show that (1) and (2) are regular, and then the result is regular. For both we make regular expressions that allow us to conclude that each is regular. Because L' is finite, even though (2) seems more complicated, it is very easy to make a regular expression for it.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What if L' were infinite?
2. What if we wanted the strings that are either in (1) or (2), but not both?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:8uy7oEgLR6o</id>
<yt:videoId>8uy7oEgLR6o</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>[April Fools] How to solve ANY Computer Science Theory Exam Question! - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=8uy7oEgLR6o"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>[April Fools] How to solve ANY Computer Science Theory Exam Question! - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/8uy7oEgLR6o?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/8uy7oEgLR6o/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we give the steps to solve any computer science theory exam question. These steps are all really important to remember, as whenever you're taking a test, the steps are almost always the same. Make sure to keep these to heart, whenever you're converting an NFA to a DFA, or using the pumping lemma!

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What steps would you use to solve a homework question?
2. What techniques would you use to solve an exam question faster?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:-SZkkMWHBvQ</id>
<yt:videoId>-SZkkMWHBvQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Chomsky Normal Form (CNF) Conversion, made EASY - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=-SZkkMWHBvQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Chomsky Normal Form (CNF) Conversion, made EASY - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/-SZkkMWHBvQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/-SZkkMWHBvQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we convert a context-free grammar into Chomsky Normal Form, and show that it works for any CFG. The process involves 5 stages: (1) ensure the start variable is not on the RHS of any rule, (2) "eliminate" epsilon-rules, (3) "eliminate" unit rules, (4) ensure the RHS is only variables or a single terminal, and (5) reduce "long" RHSes. The order of the rules is important!

Timestamps:
0:00 - Intro
1:30 - Step 1 (ensure start var not on RHS)
3:25 - Step 2 ("eliminate" epsilon rules)
9:10 - Step 3 ("eliminate" unit rules)
13:48 - Step 4 (remove mix of terminals and vars)
17:18 - Step 5 (ensure RHSes are of length at most 2)

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Can you prove why it is the case that each stage never changes the language of the CFG?
2. What if we have a regular grammar and convert it to CNF? (i.e., every rule is either A to epsilon, A to a single terminal, A to a variable B, or A to xB where x is a terminal, B a variable)

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:UCr8Zh_DTas</id>
<yt:videoId>UCr8Zh_DTas</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #65: Do(L) vs. Sq(L) - Are they Equal? Which is Regular? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=UCr8Zh_DTas"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #65: Do(L) vs. Sq(L) - Are they Equal? Which is Regular? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/UCr8Zh_DTas?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/UCr8Zh_DTas/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at two languages Do(L) vs. Sq(L), where Do(L) is the set of strings wx where w, x are in L, and Sq(L) is the set of ww where w in L. We show that indeed these two languages are not always the same. Further, we show that Do(L) is always regular whenever L is, and Sq(L) is not always regular, even when L is.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What if L is not regular? Is Do(L) always not regular? Sq(L)?
2. For what languages L is Do(L) = Sq(L)?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:fiipLIVwR9o</id>
<yt:videoId>fiipLIVwR9o</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #95: Intersection of a CFL and a regular language WITHOUT A PDA - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=fiipLIVwR9o"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #95: Intersection of a CFL and a regular language WITHOUT A PDA - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/fiipLIVwR9o?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/fiipLIVwR9o/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we consider the problem of intersecting a CFL and a regular language without using a PDA! It turns out that it is possible to do this directly, with a CFG and a DFA. The idea is simple, but we have to make some modifications first (the CFG has to be in CNF, and the DFA has to be an NFA with exactly 1 final state). Then we do a product-type construction that is similar to the PDA to CFG conversion. 

The variables model pairs of states in the NFA (representing starting and destination states), as well as a variable in the original grammar. This "triplet" variable then should generate all strings that drive the NFA from the given start to the destination state, as well as a string that the given variable can generate. At the end, we generate the rules that come out of the intersection by considering the three cases that grammars in CNF can have.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What fundamental problems can arise with this method if we did a CFG intersect a CFG here? 
2. Is it possible to remove the constraint for the DFA/NFA have exactly 1 final state?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:Rfuke5QDlak</id>
<yt:videoId>Rfuke5QDlak</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #29: Does the NFA to DFA conversion always make more states? - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=Rfuke5QDlak"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #29: Does the NFA to DFA conversion always make more states? - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/Rfuke5QDlak?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/Rfuke5QDlak/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at the question of whether the NFA to DFA conversion always makes more states or not. We show that sometimes the conversion can yield the same number of states, and sometimes even fewer states! The essential idea behind having more states is having "missing" transitions; the second for having the NFA already be a DFA; and the third exploiting epsilon closure.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Can you do an example of (3) from the video without using epsilon transitions?
2. How large can the DFA be in relation to the NFA, in general?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:yXSisUjz9iQ</id>
<yt:videoId>yXSisUjz9iQ</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #71: Closure Properties of Non-Regular Languages - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=yXSisUjz9iQ"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #71: Closure Properties of Non-Regular Languages - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/yXSisUjz9iQ?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/yXSisUjz9iQ/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at four closure properties for non-regular languages: union, intersection, complement, and star. We show that these languages are closed only under complement, and are not closed under union, intersection, or star. The reason for this is based on the complement proof, and that we can create languages such that the language and its complement (union'd, or intersected) is in fact regular. The proof for star is based on having a non-regular language with a string of very short length that repeats many times in the star of the language.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Can you find an example of a nonregular language L over *binary* alphabet such that L* is regular?
2. Are nonregular languages closed under concatenation or not?
3. What about non-context-free languages?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:5GG8goBW9gw</id>
<yt:videoId>5GG8goBW9gw</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>DIRECT and EASY proof that 0^n 1^n is not regular - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=5GG8goBW9gw"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>DIRECT and EASY proof that 0^n 1^n is not regular - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/5GG8goBW9gw?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/5GG8goBW9gw/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we show that the language {0^n 1^n : n at least 0} is not regular using a direct proof. We assumed that a DFA exists, and then derive a contradiction purely based on the fact that the DFA must repeat a "long enough" string. If we choose the string carefully, we can derive a string that the DFA accepts but is not in the language. Therefore, the language is not regular.

One could use the pumping lemma for regular languages, but this direct proof I think is more easily understood compared to a mechanical proof structure like that technique.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Prove that the language of all strings with the same number of 0s and 1s is not regular (note: this isn't 0^n 1^n!).
2. (Hard) Prove that the language of all strings with the same number of 01s and 10s with alphabet {0, 1, 2} is not regular (note: if the alphabet is {0, 1}, it is regular!).

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:KWCDQVdFmq0</id>
<yt:videoId>KWCDQVdFmq0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #64: Which of these languages is regular? (Surprising answer!) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=KWCDQVdFmq0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #64: Which of these languages is regular? (Surprising answer!) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/KWCDQVdFmq0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/KWCDQVdFmq0/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we look at three languages, and show some are regular and some are not. Recall that a language is regular if some deterministic finite automaton (DFA) recognizes it. 

The languages are:
1. L_0,1 - set of all strings with equal numbers of 0s and 1s
2. L_01,10 - set of all strings with equal numbers of 01s, and 10s
3. L_0,01 - set of all strings with equal numbers of 0s and 01s
We show that some of these are regular by producing either a regular expression for them, or that they are not regular by showing a comparison with an existing non-regular language.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What if Sigma = {0, 1, 2}? (Hint: the answers are not all the same.)
2. Which y, z are such that L_y,z is regular? What about context-free? 
3. For the ones in which L_y,z is regular, how many states are needed in a DFA to recognize them?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:jMxuL4Xzi_A</id>
<yt:videoId>jMxuL4Xzi_A</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #28: How do you convert an NFA to DFA? (Example, Powerset/Subset Construction)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=jMxuL4Xzi_A"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #28: How do you convert an NFA to DFA? (Example, Powerset/Subset Construction)</media:title>
<media:content url="https://www.youtube.com/v/jMxuL4Xzi_A?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/jMxuL4Xzi_A/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we convert a simple NFA with four states into an equivalent DFA. We first compute the epsilon-closure of the start state, and then make that the start state of the DFA. Then we "build states as needed" until we "complete" the DFA (i.e., every transition needed is present). And lastly, the final states of the DFA are the ones where the set of states contains a final state from the NFA. In our example, we ended up generating 9 states out of the possible 16.

I also give advice on how to easily convert any NFA into an equivalent DFA, and what steps are needed at each point. Note that the process does not require intuition, but rather computing which states should be included. 

Timestamps:
0:00 - Intro
0:12 - Guidelines
0:47 - Epsilon closure of {q0}
1:45 - Transitions for {q0}
3:14 - Transitions for {q2}
4:25 - Transitions for {q3} + "dead" state
5:19 - Transitions for {q1}
6:05 - Transitions for {q1,q2}
7:21 - Transitions for {q2,q3}
7:50 - Transitions for {q1,q3}
9:05 - Transitions for {q0,q1,q2}
10:10 - Final States
11:25 - Conclusion


Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. The DFA we generated had 9 states, where there are 16 possible subsets of 4 states. What happened to the other 7?
2. Can you create an NFA such that the corresponding DFA *must* have all possible states?
3. Same as Question 2, but where the NFA has no epsilon transitions.

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:UKYvP8aS7fM</id>
<yt:videoId>UKYvP8aS7fM</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>How does the DFA/NFA to Regular Expression work? (GNFA Conversion) - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=UKYvP8aS7fM"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>How does the DFA/NFA to Regular Expression work? (GNFA Conversion) - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/UKYvP8aS7fM?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/UKYvP8aS7fM/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we convert a simple NFA into a regular expression as easily as possible. We first modify the NFA so that there is a single start state with nothing going into it, and a single final state with nothing leaving it. Then we "rip" states out one at a time until we have just two states left, which contains the desired regular expression.
This is known as the "GNFA" (Generalized NFA) method.

Timestamps:
0:00 - Intro
0:39 - Overview of Steps
1:17 - Fix the NFA
2:10 - Start of Ripping States
2:39 - Rip q3
6:30 - Rip q2
9:10 - Rip q0
11:25 - Rip q1
13:05 - Conclusion

Easy Theory website: https://www.easytheory.org
Become a member: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg/join
Paypal: https://paypal.me/easytheory
Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Does the GNFA method truly work for ANY NFA?
2. What happens if we ripped the states out in a different order?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:CWei4YjTj90</id>
<yt:videoId>CWei4YjTj90</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #15: How to Union two Regular Languages, made EASY [Product Construction]</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=CWei4YjTj90"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #15: How to Union two Regular Languages, made EASY [Product Construction]</media:title>
<media:content url="https://www.youtube.com/v/CWei4YjTj90?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/CWei4YjTj90/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we create a DFA for the union of the languages of two simple DFAs, using a simple "product" construction of the states of the two machines. We just follow the transitions to form the final DFA, and also noting which states are final. We also check that our answer makes sense at the end. 

Whenever you have a problem to solve with DFAs, if you can break it down into "Problem 1 AND Problem 2" or "Problem 1 OR Problem 2", the product construction is your friend. First make the DFAs for each of Problem 1 and Problem 2, and follow the procedure in the video. The final states for either case correspond to intersection for AND, and union for OR.

Recall that a DFA is a 5-tuple (Q, Sigma, delta, q0, F) where Q is the set of states, Sigma is the alphabet, delta is the transition function, q0 is the start state, and F is the set of final state. A computation on a string is the sequence of states that are visited, starting from the start state, on that string. A string is accepted if and only if the computation ends in a final state. In the video, a final state is one with a double circle.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

PDF: https://drive.google.com/open?id=1fjO7_UjdwV88KwFaKrOTKb-MEiYGuV8Z
Solutions: https://drive.google.com/open?id=1k1Ng4a1opINOboQ7NpGnIXs0HRw59egt

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Is this the smallest DFA for this language?
2. Is there an example of applying the product construction, and every state in the resulting DFA is required?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:5-eMdNwcIck</id>
<yt:videoId>5-eMdNwcIck</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #9: DFAs for Sigma*, Empty Set, and More - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=5-eMdNwcIck"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #9: DFAs for Sigma*, Empty Set, and More - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/5-eMdNwcIck?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/5-eMdNwcIck/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we try to make sense out of various languages, and more importantly, DFAs. The languages we look at, and make DFAs for, are:
1. Sigma*
2. {epsilon}
3. empty set
4. Sigma* \ {epsilon}
5. (empty set)*
6. {epsilon}*
All of the DFAs we 

Recall that a DFA is a 5-tuple (Q, Sigma, delta, q0, F) where Q is the set of states, Sigma is the alphabet, delta is the transition function, q0 is the start state, and F is the set of final state. A computation on a string is the sequence of states that are visited, starting from the start state, on that string. A string is accepted if and only if the computation ends in a final state. In the video, a final state is one with a double circle.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

PDF of DFA: https://drive.google.com/open?id=1JHGVos8VmoQ5oKjlHYeNc2scakx37tDX
Solutions: https://drive.google.com/open?id=1Kto3JbXLNCI2ONxQ8coTnJ3NbYlK4eKx

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. Are these the smallest DFAs for these languages?
2. Is there a set S, not equal to Sigma, where S* = Sigma*?
3. Can we have two DFAs with a different number of states with the same language?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:0P82hNNbQOA</id>
<yt:videoId>0P82hNNbQOA</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #10: How to make a VERY EASY DFA for a*b*c* - Easy Theory</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=0P82hNNbQOA"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #10: How to make a VERY EASY DFA for a*b*c* - Easy Theory</media:title>
<media:content url="https://www.youtube.com/v/0P82hNNbQOA?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/0P82hNNbQOA/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we create a DFA with four states for the language a*b*c*. The primary purpose of this example is to show the thought process in directly making a DFA for a given language. There are other techniques, such as the GNFA "regular expression to NFA" conversion, coupled with the "NFA to DFA" (powerset) construction, but this is much simpler (in my opinion).

Recall that a DFA is a 5-tuple (Q, Sigma, delta, q0, F) where Q is the set of states, Sigma is the alphabet, delta is the transition function, q0 is the start state, and F is the set of final state. A computation on a string is the sequence of states that are visited, starting from the start state, on that string. A string is accepted if and only if the computation ends in a final state. In the video, a final state is one with a double circle.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

PDF of DFA: https://drive.google.com/open?id=16ezjiSUzO9ULc3RcnCJkAkr2ga6KTRIL
Solutions: https://drive.google.com/open?id=1EDd7jRvXhsNePdLQ56KZmzp-EscFT7lY

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. How do you make a DFA for the COMPLEMENT of a*b*c*?
2. How do you make a DFA for a+b+c+ (a+ means at least 1 a, etc.)?
3. Is it possible to make a DFA with fewer states than this one?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
<entry>
<id>yt:video:70DAP_E-Xd0</id>
<yt:videoId>70DAP_E-Xd0</yt:videoId>
<yt:channelId>UC3VY6RTXegnoSD_q446oBdg</yt:channelId>
<title>Theory of Computation #4: How to easily analyze a DFA (Q, Sigma, delta, q0, F)</title>
<link rel="alternate" href="https://www.youtube.com/watch?v=70DAP_E-Xd0"/>
<author>
<name>Easy Theory</name>
<uri>https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg</uri>
</author>
<published>2020-03-20T23:05:58+00:00</published>
<updated>HZ</updated>
<media:group>
<media:title>Theory of Computation #4: How to easily analyze a DFA (Q, Sigma, delta, q0, F)</media:title>
<media:content url="https://www.youtube.com/v/70DAP_E-Xd0?version=3" type="application/x-shockwave-flash" width="640" height="390"/>
<media:thumbnail url="https://i2.ytimg.com/vi/70DAP_E-Xd0/hqdefault.jpg" width="480" height="360"/>
<media:description>Here we analyze a simple DFA (Deterministic Finite Automaton) by looking at its state set, some transitions, its start state, the set of final states it has, as well as computing on a given string. 

Recall that a DFA is a 5-tuple (Q, Sigma, delta, q0, F) where Q is the set of states, Sigma is the alphabet, delta is the transition function, q0 is the start state, and F is the set of final state. A computation on a string is the sequence of states that are visited, starting from the start state, on that string. A string is accepted if and only if the computation ends in a final state. In the video, a final state is one with a double circle.

Patreon: https://www.patreon.com/easytheory
Facebook: https://www.facebook.com/easytheory/
Twitter: https://twitter.com/EasyTheory

PDF of DFA: https://drive.google.com/open?id=1LbV3HP-osfSwmKt_XVoCddwK5-JMOE6W
Solutions: https://drive.google.com/open?id=1BxojD5Zg-uW50v8gnllThwfoO0xr95gx

If you like this content, please consider subscribing to my channel: https://www.youtube.com/channel/UC3VY6RTXegnoSD_q446oBdg?sub_confirmation=1

▶ADDITIONAL QUESTIONS◀
1. What is Q - F for this DFA?
2. What is the language of this DFA?
3. Is the language of this DFA regular?

▶SEND ME THEORY QUESTIONS◀
ryan.e.dougherty@icloud.com

▶ABOUT ME◀
I am a professor of Computer Science, and am passionate about CS theory. I have taught over 12 courses at Arizona State University, as well as Colgate University, including several sections of undergraduate theory.

▶ABOUT THIS CHANNEL◀
The theory of computation is perhaps the fundamental
theory of computer science. It sets out to define, mathematically, what
exactly computation is, what is feasible to solve using a computer,
and also what is not possible to solve using a computer. 
The main objective is to define a computer mathematically, without the
reliance on real-world computers, hardware or software, or the plethora
of programming languages we have in use today. The notion of a Turing
machine serves this purpose and defines what we believe is the crux of
all computable functions.

This channel is also about weaker forms of computation, concentrating on
two classes: regular languages and context-free languages. These two
models help understand what we can do with restricted
means of computation, and offer a rich theory using which you can
hone your mathematical skills in reasoning with simple machines and
the languages they define. 

However, they are not simply there as a weak form of computation--the most attractive aspect of them is that problems formulated on them
are tractable, i.e. we can build efficient algorithms to reason
with objects such as finite automata, context-free grammars and
pushdown automata. For example, we can model a piece of hardware (a circuit)
as a finite-state system and solve whether the circuit satisfies a property
(like whether it performs addition of 16-bit registers correctly). 
We can model the syntax of a programming language using a grammar, and
build algorithms that check if a string parses according to this grammar.

On the other hand, most problems that ask properties about Turing machines
are undecidable.
This Youtube channel will help you see and prove that several tasks involving Turing machines are unsolvable---i.e., no computer, no software, can solve it. For example,
you will see that there is no software that can check whether a 
C program will halt on a particular input. To prove something is possible is, of course, challenging. 
But to show something is impossible is rare in computer
science, and very humbling.</media:description>
<media:community>
<media:starRating count="0" average="0.0" min="1" max="5"/>
<media:statistics views="1000"/>
</media:community>
</media:group>
</entry>
</feed>
